<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/ecuador_boundary.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/ecuador_boundary.py" />
              <option name="originalContent" value="import os&#10;import requests&#10;from pathlib import Path&#10;from core.paths import Paths&#10;&#10;ECU_URL = &quot;https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries/ECU.geojson&quot;&#10;&#10;def get_ecuador_geojson():&#10;    Paths.ensure()&#10;    out_path = Paths.boundaries_dir / &quot;ecuador.geojson&quot;&#10;    if not out_path.exists():&#10;        print(&quot;Descargando el contorno de Ecuador...&quot;)&#10;        r = requests.get(ECU_URL, timeout=30)&#10;        if r.status_code == 200:&#10;            out_path.write_bytes(r.content)&#10;            print(&quot;GeoJSON de Ecuador guardado en&quot;, out_path)&#10;        else:&#10;            print(&quot;No se pudo descargar el GeoJSON de Ecuador.&quot;)&#10;            return None&#10;    return str(out_path)" />
              <option name="updatedContent" value="import os&#10;import requests&#10;from pathlib import Path&#10;import json&#10;import time&#10;from core.paths import Paths&#10;&#10;# Múltiples URLs para mayor confiabilidad&#10;ECU_URLS = [&#10;    &quot;https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries/ECU.geojson&quot;,&#10;    &quot;https://raw.githubusercontent.com/johan/world.geo.json/master/countries/ECU.geo.json&quot;&#10;]&#10;&#10;# GeoJSON básico de Ecuador como respaldo (simplificado)&#10;BASIC_ECUADOR_GEOJSON = {&#10;    &quot;type&quot;: &quot;FeatureCollection&quot;,&#10;    &quot;features&quot;: [{&#10;        &quot;type&quot;: &quot;Feature&quot;,&#10;        &quot;properties&quot;: {&quot;name&quot;: &quot;Ecuador&quot;},&#10;        &quot;geometry&quot;: {&#10;            &quot;type&quot;: &quot;Polygon&quot;,&#10;            &quot;coordinates&quot;: [[&#10;                [-81.0, -5.0], [-81.0, 1.5], &#10;                [-75.0, 1.5], [-75.0, -5.0], &#10;                [-81.0, -5.0]&#10;            ]]&#10;        }&#10;    }]&#10;}&#10;&#10;def get_ecuador_geojson():&#10;    &quot;&quot;&quot;&#10;    Obtiene el archivo GeoJSON de Ecuador.&#10;    Primero intenta usar un archivo local, luego descarga desde internet,&#10;    y finalmente usa un contorno básico como respaldo si todo lo demás falla.&#10;    &quot;&quot;&quot;&#10;    Paths.ensure()&#10;    out_path = Paths.ecuador_geojson&#10;    &#10;    # 1. Verificar si el archivo ya existe localmente&#10;    if out_path.exists():&#10;        print(f&quot;Usando archivo GeoJSON existente: {out_path}&quot;)&#10;        return str(out_path)&#10;    &#10;    print(&quot;El archivo GeoJSON de Ecuador no existe localmente, intentando descargar...&quot;)&#10;    &#10;    # 2. Intentar descargar de múltiples URLs&#10;    for i, url in enumerate(ECU_URLS):&#10;        try:&#10;            print(f&quot;Intentando descargar desde {url}...&quot;)&#10;            r = requests.get(url, timeout=10)&#10;            if r.status_code == 200:&#10;                out_path.write_bytes(r.content)&#10;                print(f&quot;GeoJSON de Ecuador guardado en {out_path}&quot;)&#10;                return str(out_path)&#10;            else:&#10;                print(f&quot;Error al descargar (HTTP {r.status_code})&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error al descargar: {e}&quot;)&#10;            if i &lt; len(ECU_URLS) - 1:  # Si no es el último intento&#10;                print(&quot;Intentando con URL alternativa...&quot;)&#10;                time.sleep(1)  # Pequeña pausa antes del siguiente intento&#10;    &#10;    # 3. Usar GeoJSON básico como último recurso&#10;    print(&quot;Usando contorno básico de Ecuador como respaldo&quot;)&#10;    with open(out_path, 'w') as f:&#10;        json.dump(BASIC_ECUADOR_GEOJSON, f)&#10;    &#10;    return str(out_path)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/hgt_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/hgt_utils.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import numpy as np&#10;import geopandas as gpd&#10;from shapely.geometry import box&#10;from core.paths import Paths&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;HGT_PATTERN = re.compile(r'([NS])(\d{2})([EW])(\d{3})\.hgt$', re.IGNORECASE)&#10;&#10;def parse_hgt_filename(fname: str):&#10;    m = HGT_PATTERN.search(os.path.basename(fname))&#10;    if not m:&#10;        return None&#10;    lat = int(m.group(2)) * (1 if m.group(1).upper() == &quot;N&quot; else -1)&#10;    lon = int(m.group(4)) * (1 if m.group(3).upper() == &quot;E&quot; else -1)&#10;    return lat, lon&#10;&#10;def find_hgt_files(root_dir=None, only_ecuador=True):&#10;    if root_dir is None:&#10;        root_dir = str(Paths.hgt_dir)&#10;    hgt_files = []&#10;    for dirpath, _, filenames in os.walk(root_dir):&#10;        for fn in filenames:&#10;            if fn.lower().endswith(&quot;.hgt&quot;):&#10;                coords = parse_hgt_filename(fn)&#10;                if coords:&#10;                    hgt_files.append({&#10;                        &quot;path&quot;: os.path.join(dirpath, fn),&#10;                        &quot;lat&quot;: coords[0],&#10;                        &quot;lon&quot;: coords[1],&#10;                        &quot;name&quot;: fn&#10;                    })&#10;    if only_ecuador and hgt_files:&#10;        geojson = get_ecuador_geojson()&#10;        if geojson:&#10;            gdf = gpd.read_file(geojson)&#10;            def in_ec(lat, lon):&#10;                tile = box(lon, lat, lon+1, lat+1)&#10;                return gdf.intersects(tile).any()&#10;            hgt_files = [f for f in hgt_files if in_ec(f[&quot;lat&quot;], f[&quot;lon&quot;])]&#10;    return hgt_files&#10;&#10;def read_hgt_array(hgt_path: str):&#10;    with open(hgt_path, &quot;rb&quot;) as f:&#10;        data = np.fromfile(f, dtype=&quot;&gt;i2&quot;)&#10;    size = int(np.sqrt(data.size))&#10;    if size * size != data.size:&#10;        raise ValueError(f&quot;Archivo HGT no cuadrado: {hgt_path}&quot;)&#10;    Z = data.reshape((size, size)).astype(float)&#10;    # manejar voids SRTM&#10;    void_mask = Z &lt;= -32000&#10;    if void_mask.any():&#10;        Z[void_mask] = np.nan&#10;        Z = np.where(np.isnan(Z), np.nanmin(Z), Z)&#10;    return Z" />
              <option name="updatedContent" value="import os&#10;import re&#10;import numpy as np&#10;import geopandas as gpd&#10;from shapely.geometry import box&#10;from core.paths import Paths&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;HGT_PATTERN = re.compile(r'([NS])(\d{2})([EW])(\d{3})\.hgt$', re.IGNORECASE)&#10;&#10;def parse_hgt_filename(fname: str):&#10;    m = HGT_PATTERN.search(os.path.basename(fname))&#10;    if not m:&#10;        return None&#10;    lat = int(m.group(2)) * (1 if m.group(1).upper() == &quot;N&quot; else -1)&#10;    lon = int(m.group(4)) * (1 if m.group(3).upper() == &quot;E&quot; else -1)&#10;    return lat, lon&#10;&#10;def find_hgt_files(root_dir=None, only_ecuador=True):&#10;    &quot;&quot;&quot;&#10;    Busca archivos HGT en el directorio especificado.&#10;    &#10;    Args:&#10;        root_dir: Directorio donde buscar archivos HGT. Si es None, usa Paths.hgt_dir&#10;        only_ecuador: Si True, filtra solo archivos que intersectan con Ecuador&#10;        &#10;    Returns:&#10;        Lista de diccionarios con información de los archivos HGT encontrados&#10;    &quot;&quot;&quot;&#10;    if root_dir is None:&#10;        root_dir = str(Paths.hgt_dir)&#10;    &#10;    print(f&quot;Buscando archivos HGT en: {root_dir}&quot;)&#10;    &#10;    hgt_files = []&#10;    for dirpath, _, filenames in os.walk(root_dir):&#10;        for fn in filenames:&#10;            if fn.lower().endswith(&quot;.hgt&quot;):&#10;                coords = parse_hgt_filename(fn)&#10;                if coords:&#10;                    hgt_files.append({&#10;                        &quot;path&quot;: os.path.join(dirpath, fn),&#10;                        &quot;lat&quot;: coords[0],&#10;                        &quot;lon&quot;: coords[1],&#10;                        &quot;name&quot;: fn&#10;                    })&#10;    &#10;    print(f&quot;Total de archivos HGT encontrados: {len(hgt_files)}&quot;)&#10;    &#10;    # Filtrar por Ecuador solo si se especifica y hay archivos&#10;    if only_ecuador and hgt_files:&#10;        try:&#10;            geojson = get_ecuador_geojson()&#10;            if not geojson:&#10;                print(&quot;No se pudo obtener el GeoJSON de Ecuador. Mostrando todos los archivos HGT.&quot;)&#10;                return hgt_files&#10;                &#10;            print(f&quot;Filtrando archivos HGT usando: {geojson}&quot;)&#10;            gdf = gpd.read_file(geojson)&#10;            &#10;            def in_ec(lat, lon):&#10;                tile = box(lon, lat, lon+1, lat+1)&#10;                return gdf.intersects(tile).any()&#10;                &#10;            ecuador_files = [f for f in hgt_files if in_ec(f[&quot;lat&quot;], f[&quot;lon&quot;])]&#10;            print(f&quot;Archivos HGT en Ecuador: {len(ecuador_files)}&quot;)&#10;            return ecuador_files&#10;            &#10;        except Exception as e:&#10;            print(f&quot;Error al filtrar archivos por Ecuador: {e}&quot;)&#10;            # En caso de error, retorna todos los archivos&#10;            return hgt_files&#10;    &#10;    return hgt_files&#10;&#10;def read_hgt_array(hgt_path: str):&#10;    with open(hgt_path, &quot;rb&quot;) as f:&#10;        data = np.fromfile(f, dtype=&quot;&gt;i2&quot;)&#10;    size = int(np.sqrt(data.size))&#10;    if size * size != data.size:&#10;        raise ValueError(f&quot;Archivo HGT no cuadrado: {hgt_path}&quot;)&#10;    Z = data.reshape((size, size)).astype(float)&#10;    # manejar voids SRTM&#10;    void_mask = Z &lt;= -32000&#10;    if void_mask.any():&#10;        Z[void_mask] = np.nan&#10;        Z = np.where(np.isnan(Z), np.nanmin(Z), Z)&#10;    return Z" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/paths.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/paths.py" />
              <option name="originalContent" value="from pathlib import Path&#10;import os&#10;&#10;class Paths:&#10;    project_root = Path(__file__).resolve().parents[2]&#10;&#10;    # Carpetas de datos de entrada&#10;    data_dir = project_root / &quot;data&quot;&#10;    hgt_dir = data_dir / &quot;hgt&quot;&#10;    boundaries_dir = data_dir / &quot;boundaries&quot;&#10;&#10;    # Carpetas de salida&#10;    outputs_dir = project_root / &quot;outputs&quot;&#10;    stl_dir = outputs_dir / &quot;stl&quot;&#10;    previews_dir = outputs_dir / &quot;previews&quot;&#10;&#10;    # Archivos específicos&#10;    ecuador_geojson = boundaries_dir / &quot;ecuador.geojson&quot;&#10;&#10;    @staticmethod&#10;    def ensure():&#10;        &quot;&quot;&quot;Asegura que todas las carpetas necesarias existan&quot;&quot;&quot;&#10;        for p in [&#10;            Paths.data_dir,&#10;            Paths.hgt_dir,&#10;            Paths.boundaries_dir,&#10;            Paths.outputs_dir,&#10;            Paths.stl_dir,&#10;            Paths.previews_dir&#10;        ]:&#10;            p.mkdir(parents=True, exist_ok=True)&#10;&#10;    @staticmethod&#10;    def update_stl_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de STL&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;&#10;        Paths.stl_dir = new_path&#10;        Paths.stl_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.stl_dir&#10;&#10;    @staticmethod&#10;    def update_hgt_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de HGT&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;&#10;        Paths.hgt_dir = new_path&#10;        Paths.hgt_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.hgt_dir&#10;" />
              <option name="updatedContent" value="from pathlib import Path&#10;import os&#10;&#10;class Paths:&#10;    # Corregir el cálculo de la ruta raíz del proyecto&#10;    project_root = Path(__file__).resolve().parents[1]  # Cambiado de parents[2] a parents[1]&#10;    &#10;    # Carpetas de datos de entrada&#10;    data_dir = project_root / &quot;data&quot;&#10;    hgt_dir = data_dir / &quot;hgt&quot;&#10;    boundaries_dir = data_dir / &quot;boundaries&quot;&#10;    &#10;    # Carpetas de salida&#10;    outputs_dir = project_root / &quot;outputs&quot;&#10;    stl_dir = outputs_dir / &quot;stl&quot;&#10;    previews_dir = outputs_dir / &quot;previews&quot;&#10;    &#10;    # Archivos específicos&#10;    ecuador_geojson = boundaries_dir / &quot;ecuador.geojson&quot;&#10;&#10;    @staticmethod&#10;    def ensure():&#10;        &quot;&quot;&quot;Asegura que todas las carpetas necesarias existan&quot;&quot;&quot;&#10;        for p in [&#10;            Paths.data_dir, &#10;            Paths.hgt_dir, &#10;            Paths.boundaries_dir, &#10;            Paths.outputs_dir, &#10;            Paths.stl_dir, &#10;            Paths.previews_dir&#10;        ]:&#10;            p.mkdir(parents=True, exist_ok=True)&#10;        &#10;        # Imprimir rutas para diagnóstico&#10;        print(f&quot;Rutas configuradas:&quot;)&#10;        print(f&quot;- Proyecto: {Paths.project_root}&quot;)&#10;        print(f&quot;- Datos HGT: {Paths.hgt_dir}&quot;)&#10;        print(f&quot;- Límites: {Paths.boundaries_dir}&quot;)&#10;        print(f&quot;- Salida STL: {Paths.stl_dir}&quot;)&#10;    &#10;    @staticmethod&#10;    def update_stl_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de STL&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;        &#10;        Paths.stl_dir = new_path&#10;        Paths.stl_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.stl_dir&#10;        &#10;    @staticmethod&#10;    def update_hgt_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de HGT&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;            &#10;        Paths.hgt_dir = new_path&#10;        Paths.hgt_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.hgt_dir" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/stl_generator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/stl_generator.py" />
              <option name="originalContent" value="from typing import Callable, Optional&#10;from pathlib import Path&#10;import numpy as np&#10;from scipy.ndimage import gaussian_filter&#10;import pyvista as pv&#10;from app.core.paths import Paths&#10;from app.core.hgt_utils import read_hgt_array&#10;&#10;ProgressCB = Optional[Callable[[int, str], None]]&#10;&#10;def generate_stl_from_hgt(hgt_path: str, out_dir: Optional[str] = None, progress: ProgressCB = None) -&gt; str:&#10;    def p(val, msg):&#10;        if progress: progress(val, msg)&#10;&#10;    Paths.ensure()&#10;    if out_dir is None:&#10;        out_dir = str(Paths.stl_dir)&#10;&#10;    name = Path(hgt_path).stem&#10;    out_path = str(Path(out_dir) / f&quot;{name}_solido.stl&quot;)&#10;&#10;    p(5, &quot;Leyendo HGT...&quot;)&#10;    Z = read_hgt_array(hgt_path)&#10;&#10;    p(20, &quot;Suavizando elevación...&quot;)&#10;    Z = gaussian_filter(Z, sigma=5.0, truncate=2.5)&#10;&#10;    p(30, &quot;Submuestreando...&quot;)&#10;    skip = 6&#10;    Z = Z[::skip, ::skip]&#10;    nx, ny = Z.shape&#10;    x = np.linspace(0, nx - 1, nx)&#10;    y = np.linspace(0, ny - 1, ny)&#10;    X, Y = np.meshgrid(x, y, indexing=&quot;ij&quot;)&#10;&#10;    p(40, &quot;Construyendo base y bordes...&quot;)&#10;    # Escalado vertical y normalización (similar a tu lógica)&#10;    Z_scaled = Z * 0.12&#10;    zmin, zmax = float(np.min(Z_scaled)), float(np.max(Z_scaled))&#10;    rng = zmax - zmin if zmax &gt; zmin else 1.0&#10;    Z_norm = (Z_scaled - zmin) / rng&#10;    compression_factor = 0.6&#10;    Z_comp = np.where(Z_norm &gt; 0.3, 0.3 + (Z_norm - 0.3)*compression_factor, Z_norm)&#10;    Z_scaled = zmin + Z_comp * rng&#10;&#10;    zmin = float(np.min(Z_scaled))&#10;    base_thickness = 20.0&#10;    base_height = zmin - base_thickness&#10;&#10;    # Borde suave hacia la base&#10;    edge_fade = 10&#10;    Z_smooth = Z_scaled.copy()&#10;    for i in range(edge_fade):&#10;        alpha = i / edge_fade&#10;        Z_smooth[i, :]       = np.minimum(Z_smooth[i, :],       base_height + (Z_smooth[i, :]       - base_height) * alpha)&#10;        Z_smooth[-(i+1), :]  = np.minimum(Z_smooth[-(i+1), :],  base_height + (Z_smooth[-(i+1), :]  - base_height) * alpha)&#10;        Z_smooth[:, i]       = np.minimum(Z_smooth[:, i],       base_height + (Z_smooth[:, i]       - base_height) * alpha)&#10;        Z_smooth[:, -(i+1)]  = np.minimum(Z_smooth[:, -(i+1)],  base_height + (Z_smooth[:, -(i+1)]  - base_height) * alpha)&#10;&#10;    p(55, &quot;Construyendo malla sólida...&quot;)&#10;    points = []&#10;    # superficie&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], Z_smooth[i, j]])&#10;    # base&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], base_height])&#10;&#10;    offset = nx * ny&#10;    faces = []&#10;    # top y base&#10;    for i in range(nx - 1):&#10;        for j in range(ny - 1):&#10;            p1 = i * ny + j&#10;            p2 = i * ny + (j + 1)&#10;            p3 = (i + 1) * ny + (j + 1)&#10;            p4 = (i + 1) * ny + j&#10;            faces.extend([4, p1, p2, p3, p4])&#10;            p1b, p2b, p3b, p4b = p1 + offset, p2 + offset, p3 + offset, p4 + offset&#10;            faces.extend([4, p4b, p3b, p2b, p1b])&#10;&#10;    # lados&#10;    for i in range(nx - 1):&#10;        # izquierda (j=0)&#10;        p1t = i * ny + 0&#10;        p2t = (i + 1) * ny + 0&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p1b, p2b, p2t])&#10;        # derecha (j=ny-1)&#10;        p1t = i * ny + (ny - 1)&#10;        p2t = (i + 1) * ny + (ny - 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p2b, p1b, p1t])&#10;&#10;    for j in range(ny - 1):&#10;        # arriba (i=0)&#10;        p1t = 0 * ny + j&#10;        p2t = 0 * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p2t, p2b, p1b])&#10;        # abajo (i=nx-1)&#10;        p1t = (nx - 1) * ny + j&#10;        p2t = (nx - 1) * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p1t, p1b, p2b])&#10;&#10;    p(70, &quot;Optimizando mesh...&quot;)&#10;    points_array = np.array(points, dtype=np.float32)&#10;    # convertir quads a triángulos para pyvista&#10;    triangles = []&#10;    for k in range(0, len(faces), 5):&#10;        if k + 4 &lt; len(faces):&#10;            _, a, b, c, d = faces[k:k+5]&#10;            triangles.extend([3, a, b, c])&#10;            triangles.extend([3, a, c, d])&#10;    mesh = pv.PolyData(points_array, np.array(triangles))&#10;    mesh = mesh.clean(tolerance=1e-3)&#10;&#10;    p(90, &quot;Guardando STL...&quot;)&#10;    Path(out_dir).mkdir(parents=True, exist_ok=True)&#10;    mesh.save(out_path)&#10;&#10;    p(100, &quot;Completado&quot;)&#10;    return out_path" />
              <option name="updatedContent" value="from typing import Callable, Optional&#13;&#10;from pathlib import Path&#13;&#10;import numpy as np&#13;&#10;from scipy.ndimage import gaussian_filter&#13;&#10;import pyvista as pv&#13;&#10;from core.paths import Paths&#13;&#10;from core.hgt_utils import read_hgt_array&#13;&#10;&#13;&#10;ProgressCB = Optional[Callable[[int, str], None]]&#13;&#10;&#13;&#10;def generate_stl_from_hgt(hgt_path: str, out_dir: Optional[str] = None, progress: ProgressCB = None) -&gt; str:&#13;&#10;    def p(val, msg):&#13;&#10;        if progress: progress(val, msg)&#13;&#10;&#13;&#10;    Paths.ensure()&#13;&#10;    if out_dir is None:&#13;&#10;        out_dir = str(Paths.stl_dir)&#13;&#10;&#13;&#10;    name = Path(hgt_path).stem&#13;&#10;    out_path = str(Path(out_dir) / f&quot;{name}_solido.stl&quot;)&#13;&#10;&#13;&#10;    p(5, &quot;Leyendo HGT...&quot;)&#13;&#10;    Z = read_hgt_array(hgt_path)&#13;&#10;&#13;&#10;    p(20, &quot;Suavizando elevación...&quot;)&#13;&#10;    Z = gaussian_filter(Z, sigma=5.0, truncate=2.5)&#13;&#10;&#13;&#10;    p(30, &quot;Submuestreando...&quot;)&#13;&#10;    skip = 6&#13;&#10;    Z = Z[::skip, ::skip]&#13;&#10;    nx, ny = Z.shape&#13;&#10;    x = np.linspace(0, nx - 1, nx)&#13;&#10;    y = np.linspace(0, ny - 1, ny)&#13;&#10;    X, Y = np.meshgrid(x, y, indexing=&quot;ij&quot;)&#13;&#10;&#13;&#10;    p(40, &quot;Construyendo base y bordes...&quot;)&#13;&#10;    # Escalado vertical y normalización (similar a tu lógica)&#13;&#10;    Z_scaled = Z * 0.12&#13;&#10;    zmin, zmax = float(np.min(Z_scaled)), float(np.max(Z_scaled))&#13;&#10;    rng = zmax - zmin if zmax &gt; zmin else 1.0&#13;&#10;    Z_norm = (Z_scaled - zmin) / rng&#13;&#10;    compression_factor = 0.6&#13;&#10;    Z_comp = np.where(Z_norm &gt; 0.3, 0.3 + (Z_norm - 0.3)*compression_factor, Z_norm)&#13;&#10;    Z_scaled = zmin + Z_comp * rng&#13;&#10;&#13;&#10;    zmin = float(np.min(Z_scaled))&#13;&#10;    base_thickness = 20.0&#13;&#10;    base_height = zmin - base_thickness&#13;&#10;&#13;&#10;    # Borde suave hacia la base&#13;&#10;    edge_fade = 10&#13;&#10;    Z_smooth = Z_scaled.copy()&#13;&#10;    for i in range(edge_fade):&#13;&#10;        alpha = i / edge_fade&#13;&#10;        Z_smooth[i, :]       = np.minimum(Z_smooth[i, :],       base_height + (Z_smooth[i, :]       - base_height) * alpha)&#13;&#10;        Z_smooth[-(i+1), :]  = np.minimum(Z_smooth[-(i+1), :],  base_height + (Z_smooth[-(i+1), :]  - base_height) * alpha)&#13;&#10;        Z_smooth[:, i]       = np.minimum(Z_smooth[:, i],       base_height + (Z_smooth[:, i]       - base_height) * alpha)&#13;&#10;        Z_smooth[:, -(i+1)]  = np.minimum(Z_smooth[:, -(i+1)],  base_height + (Z_smooth[:, -(i+1)]  - base_height) * alpha)&#13;&#10;&#13;&#10;    p(55, &quot;Construyendo malla sólida...&quot;)&#13;&#10;    points = []&#13;&#10;    # superficie&#13;&#10;    for i in range(nx):&#13;&#10;        for j in range(ny):&#13;&#10;            points.append([X[i, j], Y[i, j], Z_smooth[i, j]])&#13;&#10;    # base&#13;&#10;    for i in range(nx):&#13;&#10;        for j in range(ny):&#13;&#10;            points.append([X[i, j], Y[i, j], base_height])&#13;&#10;&#13;&#10;    offset = nx * ny&#13;&#10;    faces = []&#13;&#10;    # top y base&#13;&#10;    for i in range(nx - 1):&#13;&#10;        for j in range(ny - 1):&#13;&#10;            p1 = i * ny + j&#13;&#10;            p2 = i * ny + (j + 1)&#13;&#10;            p3 = (i + 1) * ny + (j + 1)&#13;&#10;            p4 = (i + 1) * ny + j&#13;&#10;            faces.extend([4, p1, p2, p3, p4])&#13;&#10;            p1b, p2b, p3b, p4b = p1 + offset, p2 + offset, p3 + offset, p4 + offset&#13;&#10;            faces.extend([4, p4b, p3b, p2b, p1b])&#13;&#10;&#13;&#10;    # lados&#13;&#10;    for i in range(nx - 1):&#13;&#10;        # izquierda (j=0)&#13;&#10;        p1t = i * ny + 0&#13;&#10;        p2t = (i + 1) * ny + 0&#13;&#10;        p1b = p1t + offset&#13;&#10;        p2b = p2t + offset&#13;&#10;        faces.extend([4, p1t, p1b, p2b, p2t])&#13;&#10;        # derecha (j=ny-1)&#13;&#10;        p1t = i * ny + (ny - 1)&#13;&#10;        p2t = (i + 1) * ny + (ny - 1)&#13;&#10;        p1b = p1t + offset&#13;&#10;        p2b = p2t + offset&#13;&#10;        faces.extend([4, p2t, p2b, p1b, p1t])&#13;&#10;&#13;&#10;    for j in range(ny - 1):&#13;&#10;        # arriba (i=0)&#13;&#10;        p1t = 0 * ny + j&#13;&#10;        p2t = 0 * ny + (j + 1)&#13;&#10;        p1b = p1t + offset&#13;&#10;        p2b = p2t + offset&#13;&#10;        faces.extend([4, p1t, p2t, p2b, p1b])&#13;&#10;        # abajo (i=nx-1)&#13;&#10;        p1t = (nx - 1) * ny + j&#13;&#10;        p2t = (nx - 1) * ny + (j + 1)&#13;&#10;        p1b = p1t + offset&#13;&#10;        p2b = p2t + offset&#13;&#10;        faces.extend([4, p2t, p1t, p1b, p2b])&#13;&#10;&#13;&#10;    p(70, &quot;Optimizando mesh...&quot;)&#13;&#10;    points_array = np.array(points, dtype=np.float32)&#13;&#10;    # convertir quads a triángulos para pyvista&#13;&#10;    triangles = []&#13;&#10;    for k in range(0, len(faces), 5):&#13;&#10;        if k + 4 &lt; len(faces):&#13;&#10;            _, a, b, c, d = faces[k:k+5]&#13;&#10;            triangles.extend([3, a, b, c])&#13;&#10;            triangles.extend([3, a, c, d])&#13;&#10;    mesh = pv.PolyData(points_array, np.array(triangles))&#13;&#10;    mesh = mesh.clean(tolerance=1e-3)&#13;&#10;&#13;&#10;    p(90, &quot;Guardando STL...&quot;)&#13;&#10;    Path(out_dir).mkdir(parents=True, exist_ok=True)&#13;&#10;    mesh.save(out_path)&#13;&#10;&#13;&#10;    p(100, &quot;Completado&quot;)&#13;&#10;    return out_path" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import sys&#10;from PyQt6.QtWidgets import QApplication&#10;from app.ui.main_window import MainWindow&#10;&#10;def main():&#10;    app = QApplication(sys.argv)&#10;    win = MainWindow()&#10;    win.show()&#10;    sys.exit(app.exec())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
              <option name="updatedContent" value="import sys&#10;from PyQt6.QtWidgets import QApplication&#10;from ui.main_window import MainWindow&#10;&#10;def main():&#10;    app = QApplication(sys.argv)&#10;    win = MainWindow()&#10;    win.show()&#10;    sys.exit(app.exec())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="updatedContent" value="PyQt6&gt;=6.4.0&#10;numpy&gt;=1.24.0&#10;scipy&gt;=1.10.0&#10;matplotlib&gt;=3.7.0&#10;geopandas&gt;=0.12.0&#10;shapely&gt;=2.0.0&#10;pyvista&gt;=0.38.0&#10;pyvistaqt&gt;=0.9.0&#10;requests&gt;=2.28.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/main_window.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/main_window.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QPushButton, QFileDialog,&#10;                         QStackedWidget, QMessageBox, QLabel, QHBoxLayout, QDialog)&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtGui import QIcon, QPixmap&#10;from ui.map_selector_widget import MapSelectorWidget&#10;from ui.progress_dialog import ProgressDialog&#10;from ui.viewer_3d import Viewer3D&#10;from ui.workers import STLWorker&#10;from core.paths import Paths&#10;import os&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Mapa 3D Ecuador - Generador de STL&quot;)&#10;        self.resize(1200, 800)&#10;        Paths.ensure()&#10;&#10;        self.stack = QStackedWidget()&#10;        self.setCentralWidget(self.stack)&#10;&#10;        # Main menu&#10;        self.menu_page = QWidget()&#10;        self.create_main_menu()&#10;        self.stack.addWidget(self.menu_page)&#10;&#10;        # Map page&#10;        self.map_page = MapSelectorWidget(on_selected=self._on_tile_selected, on_back=self._go_menu)&#10;        self.stack.addWidget(self.map_page)&#10;&#10;        # Viewer page&#10;        self.viewer_page = Viewer3D(back_cb=self._go_menu)&#10;        self.stack.addWidget(self.viewer_page)&#10;&#10;        # Variables de estado&#10;        self.progress_dlg = None&#10;        self.worker = None&#10;&#10;        # Mostrar menú principal al inicio&#10;        self._go_menu()&#10;&#10;    def create_main_menu(self):&#10;        layout = QVBoxLayout(self.menu_page)&#10;&#10;        # Título&#10;        title_label = QLabel(&quot;Generador 3D de Terreno - Ecuador&quot;)&#10;        title_label.setStyleSheet(&quot;font-size: 24pt; font-weight: bold; color: #2c3e50; margin: 20px;&quot;)&#10;        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(title_label)&#10;&#10;        # Descripción&#10;        desc_label = QLabel(&quot;Seleccione una opción para comenzar:&quot;)&#10;        desc_label.setStyleSheet(&quot;font-size: 14pt; margin-bottom: 20px;&quot;)&#10;        desc_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(desc_label)&#10;&#10;        # Contenedor principal para los botones&#10;        btn_container = QWidget()&#10;        btn_layout = QVBoxLayout(btn_container)&#10;&#10;        # Estilo común para botones&#10;        button_style = &quot;&quot;&quot;&#10;        QPushButton {&#10;            font-size: 14pt;&#10;            padding: 12px;&#10;            margin: 10px 50px;&#10;            background-color: #3498db;&#10;            color: white;&#10;            border-radius: 8px;&#10;            min-width: 300px;&#10;        }&#10;        QPushButton:hover {&#10;            background-color: #2980b9;&#10;        }&#10;        &quot;&quot;&quot;&#10;&#10;        # Botones principales&#10;        self.btn_map = QPushButton(&quot;Seleccionar Zona en Mapa&quot;)&#10;        self.btn_map.setStyleSheet(button_style)&#10;        self.btn_open_stl = QPushButton(&quot;Abrir Modelo STL Existente&quot;)&#10;        self.btn_open_stl.setStyleSheet(button_style)&#10;        self.btn_settings = QPushButton(&quot;Configurar Carpetas de Datos&quot;)&#10;        self.btn_settings.setStyleSheet(button_style)&#10;        self.btn_exit = QPushButton(&quot;Salir&quot;)&#10;        self.btn_exit.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#e74c3c&quot;).replace(&quot;#2980b9&quot;, &quot;#c0392b&quot;))&#10;&#10;        btn_layout.addWidget(self.btn_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_open_stl, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_settings, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_exit, alignment=Qt.AlignmentFlag.AlignCenter)&#10;&#10;        layout.addWidget(btn_container)&#10;        layout.addStretch()&#10;&#10;        # Conexiones de botones&#10;        self.btn_map.clicked.connect(self._go_map)&#10;        self.btn_open_stl.clicked.connect(self._open_stl)&#10;        self.btn_settings.clicked.connect(self._settings)&#10;        self.btn_exit.clicked.connect(self.close)&#10;&#10;    def _go_menu(self):&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;    def _go_map(self):&#10;        self.map_page.load()&#10;        self.stack.setCurrentWidget(self.map_page)&#10;&#10;    def _open_stl(self):&#10;        fn, _ = QFileDialog.getOpenFileName(self, &quot;Abrir STL&quot;, str(Paths.stl_dir), &quot;STL (*.stl)&quot;)&#10;        if fn:&#10;            # Mostrar diálogo de carga mientras se abre el modelo&#10;            loading_dialog = ProgressDialog(&quot;Cargando modelo STL...&quot;)&#10;            loading_dialog.show()&#10;&#10;            def open_model():&#10;                loading_dialog.update_progress(50, f&quot;Cargando {os.path.basename(fn)}...&quot;)&#10;                self.viewer_page.load_stl(fn)&#10;                self.stack.setCurrentWidget(self.viewer_page)&#10;                loading_dialog.close()&#10;&#10;            # Usar QTimer para permitir que se muestre el diálogo antes de cargar&#10;            QTimer.singleShot(300, open_model)&#10;&#10;    def _settings(self):&#10;        # Configuración de carpetas&#10;        settings_dialog = QDialog(self)&#10;        settings_dialog.setWindowTitle(&quot;Configuración&quot;)&#10;        settings_dialog.setMinimumWidth(500)&#10;&#10;        layout = QVBoxLayout(settings_dialog)&#10;&#10;        # HGT Directory&#10;        hgt_layout = QHBoxLayout()&#10;        hgt_label = QLabel(&quot;Carpeta de archivos HGT:&quot;)&#10;        hgt_path = QLabel(str(Paths.hgt_dir))&#10;        hgt_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        hgt_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        hgt_layout.addWidget(hgt_label)&#10;        hgt_layout.addWidget(hgt_path, 1)  # 1 = stretch factor&#10;        hgt_layout.addWidget(hgt_btn)&#10;&#10;        # STL Directory&#10;        stl_layout = QHBoxLayout()&#10;        stl_label = QLabel(&quot;Carpeta de modelos STL:&quot;)&#10;        stl_path = QLabel(str(Paths.stl_dir))&#10;        stl_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        stl_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        stl_layout.addWidget(stl_label)&#10;        stl_layout.addWidget(stl_path, 1)  # 1 = stretch factor&#10;        stl_layout.addWidget(stl_btn)&#10;&#10;        # Close button&#10;        close_btn = QPushButton(&quot;Cerrar&quot;)&#10;        close_btn.clicked.connect(settings_dialog.accept)&#10;&#10;        layout.addLayout(hgt_layout)&#10;        layout.addLayout(stl_layout)&#10;        layout.addWidget(close_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;        # Connect buttons&#10;        def change_hgt():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de HGT&quot;, str(Paths.hgt_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_hgt_dir(new_dir)&#10;                self.map_page.hgt_root = str(Paths.hgt_dir)&#10;                hgt_path.setText(str(Paths.hgt_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta HGT configurada en:\n{Paths.hgt_dir}&quot;)&#10;&#10;        def change_stl():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de STL&quot;, str(Paths.stl_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_stl_dir(new_dir)&#10;                stl_path.setText(str(Paths.stl_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta STL configurada en:\n{Paths.stl_dir}&quot;)&#10;&#10;        hgt_btn.clicked.connect(change_hgt)&#10;        stl_btn.clicked.connect(change_stl)&#10;&#10;        settings_dialog.exec()&#10;&#10;    def _on_tile_selected(self, hgt_path: str):&#10;        # 1. Volver al menú principal y mostrar progreso&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;        # 2. Mostrar diálogo de progreso con estilo mejorado&#10;        self.progress_dlg = ProgressDialog(&quot;Generando modelo 3D...&quot;)&#10;        self.progress_dlg.setWindowTitle(f&quot;Generando modelo de {os.path.basename(hgt_path)}&quot;)&#10;        self.progress_dlg.show()&#10;&#10;        # 3. Iniciar worker en segundo plano&#10;        self.worker = STLWorker(hgt_path)&#10;        self.worker.progress.connect(self.progress_dlg.update_progress)&#10;        self.worker.finished.connect(self._on_generation_finished)&#10;        self.worker.start()&#10;&#10;    def _on_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Modelo generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QPushButton, QFileDialog,&#10;                         QStackedWidget, QMessageBox, QLabel, QHBoxLayout, QDialog)&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtGui import QIcon, QPixmap&#10;from ui.map_selector_widget import MapSelectorWidget&#10;from ui.progress_dialog import ProgressDialog&#10;from ui.viewer_3d import Viewer3D&#10;from ui.workers import STLWorker&#10;from core.paths import Paths&#10;import os&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Mapa 3D Ecuador - Generador de STL&quot;)&#10;        self.resize(1200, 800)&#10;        Paths.ensure()&#10;&#10;        self.stack = QStackedWidget()&#10;        self.setCentralWidget(self.stack)&#10;&#10;        # Main menu&#10;        self.menu_page = QWidget()&#10;        self.create_main_menu()&#10;        self.stack.addWidget(self.menu_page)&#10;&#10;        # Map page&#10;        self.map_page = MapSelectorWidget(on_selected=self._on_tile_selected, on_back=self._go_menu)&#10;        self.stack.addWidget(self.map_page)&#10;&#10;        # Viewer page&#10;        self.viewer_page = Viewer3D(back_cb=self._go_menu)&#10;        self.stack.addWidget(self.viewer_page)&#10;&#10;        # Variables de estado&#10;        self.progress_dlg = None&#10;        self.worker = None&#10;&#10;        # Mostrar menú principal al inicio&#10;        self._go_menu()&#10;&#10;    def create_main_menu(self):&#10;        layout = QVBoxLayout(self.menu_page)&#10;        &#10;        # Título&#10;        title_label = QLabel(&quot;Generador 3D de Terreno - Ecuador&quot;)&#10;        title_label.setStyleSheet(&quot;font-size: 24pt; font-weight: bold; color: #2c3e50; margin: 20px;&quot;)&#10;        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(title_label)&#10;        &#10;        # Descripción&#10;        desc_label = QLabel(&quot;Seleccione una opción para comenzar:&quot;)&#10;        desc_label.setStyleSheet(&quot;font-size: 14pt; margin-bottom: 20px;&quot;)&#10;        desc_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(desc_label)&#10;        &#10;        # Contenedor principal para los botones&#10;        btn_container = QWidget()&#10;        btn_layout = QVBoxLayout(btn_container)&#10;        &#10;        # Estilo común para botones&#10;        button_style = &quot;&quot;&quot;&#10;        QPushButton {&#10;            font-size: 14pt;&#10;            padding: 12px;&#10;            margin: 10px 50px;&#10;            background-color: #3498db;&#10;            color: white;&#10;            border-radius: 8px;&#10;            min-width: 300px;&#10;        }&#10;        QPushButton:hover {&#10;            background-color: #2980b9;&#10;        }&#10;        &quot;&quot;&quot;&#10;        &#10;        # Botones principales&#10;        self.btn_map = QPushButton(&quot;Seleccionar Zona en Mapa&quot;)&#10;        self.btn_map.setStyleSheet(button_style)&#10;        &#10;        # Nuevo botón para generar todo el mapa&#10;        self.btn_full_map = QPushButton(&quot;Generar Todo el Mapa de Ecuador&quot;)&#10;        self.btn_full_map.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#27ae60&quot;).replace(&quot;#2980b9&quot;, &quot;#219955&quot;))&#10;        &#10;        self.btn_open_stl = QPushButton(&quot;Abrir Modelo STL Existente&quot;)&#10;        self.btn_open_stl.setStyleSheet(button_style)&#10;        self.btn_settings = QPushButton(&quot;Configurar Carpetas de Datos&quot;)&#10;        self.btn_settings.setStyleSheet(button_style)&#10;        self.btn_exit = QPushButton(&quot;Salir&quot;)&#10;        self.btn_exit.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#e74c3c&quot;).replace(&quot;#2980b9&quot;, &quot;#c0392b&quot;))&#10;        &#10;        btn_layout.addWidget(self.btn_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_full_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_open_stl, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_settings, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_exit, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        &#10;        layout.addWidget(btn_container)&#10;        layout.addStretch()&#10;        &#10;        # Conexiones de botones&#10;        self.btn_map.clicked.connect(self._go_map)&#10;        self.btn_full_map.clicked.connect(self._generate_full_map)&#10;        self.btn_open_stl.clicked.connect(self._open_stl)&#10;        self.btn_settings.clicked.connect(self._settings)&#10;        self.btn_exit.clicked.connect(self.close)&#10;&#10;    def _go_menu(self):&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;    def _go_map(self):&#10;        self.map_page.load()&#10;        self.stack.setCurrentWidget(self.map_page)&#10;&#10;    def _open_stl(self):&#10;        fn, _ = QFileDialog.getOpenFileName(self, &quot;Abrir STL&quot;, str(Paths.stl_dir), &quot;STL (*.stl)&quot;)&#10;        if fn:&#10;            # Mostrar diálogo de carga mientras se abre el modelo&#10;            loading_dialog = ProgressDialog(&quot;Cargando modelo STL...&quot;)&#10;            loading_dialog.show()&#10;&#10;            def open_model():&#10;                loading_dialog.update_progress(50, f&quot;Cargando {os.path.basename(fn)}...&quot;)&#10;                self.viewer_page.load_stl(fn)&#10;                self.stack.setCurrentWidget(self.viewer_page)&#10;                loading_dialog.close()&#10;&#10;            # Usar QTimer para permitir que se muestre el diálogo antes de cargar&#10;            QTimer.singleShot(300, open_model)&#10;&#10;    def _settings(self):&#10;        # Configuración de carpetas&#10;        settings_dialog = QDialog(self)&#10;        settings_dialog.setWindowTitle(&quot;Configuración&quot;)&#10;        settings_dialog.setMinimumWidth(500)&#10;&#10;        layout = QVBoxLayout(settings_dialog)&#10;&#10;        # HGT Directory&#10;        hgt_layout = QHBoxLayout()&#10;        hgt_label = QLabel(&quot;Carpeta de archivos HGT:&quot;)&#10;        hgt_path = QLabel(str(Paths.hgt_dir))&#10;        hgt_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        hgt_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        hgt_layout.addWidget(hgt_label)&#10;        hgt_layout.addWidget(hgt_path, 1)  # 1 = stretch factor&#10;        hgt_layout.addWidget(hgt_btn)&#10;&#10;        # STL Directory&#10;        stl_layout = QHBoxLayout()&#10;        stl_label = QLabel(&quot;Carpeta de modelos STL:&quot;)&#10;        stl_path = QLabel(str(Paths.stl_dir))&#10;        stl_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        stl_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        stl_layout.addWidget(stl_label)&#10;        stl_layout.addWidget(stl_path, 1)  # 1 = stretch factor&#10;        stl_layout.addWidget(stl_btn)&#10;&#10;        # Close button&#10;        close_btn = QPushButton(&quot;Cerrar&quot;)&#10;        close_btn.clicked.connect(settings_dialog.accept)&#10;&#10;        layout.addLayout(hgt_layout)&#10;        layout.addLayout(stl_layout)&#10;        layout.addWidget(close_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;        # Connect buttons&#10;        def change_hgt():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de HGT&quot;, str(Paths.hgt_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_hgt_dir(new_dir)&#10;                self.map_page.hgt_root = str(Paths.hgt_dir)&#10;                hgt_path.setText(str(Paths.hgt_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta HGT configurada en:\n{Paths.hgt_dir}&quot;)&#10;&#10;        def change_stl():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de STL&quot;, str(Paths.stl_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_stl_dir(new_dir)&#10;                stl_path.setText(str(Paths.stl_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta STL configurada en:\n{Paths.stl_dir}&quot;)&#10;&#10;        hgt_btn.clicked.connect(change_hgt)&#10;        stl_btn.clicked.connect(change_stl)&#10;&#10;        settings_dialog.exec()&#10;&#10;    def _on_tile_selected(self, hgt_path: str):&#10;        # 1. Volver al menú principal y mostrar progreso&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;        # 2. Mostrar diálogo de progreso con estilo mejorado&#10;        self.progress_dlg = ProgressDialog(&quot;Generando modelo 3D...&quot;)&#10;        self.progress_dlg.setWindowTitle(f&quot;Generando modelo de {os.path.basename(hgt_path)}&quot;)&#10;        self.progress_dlg.show()&#10;&#10;        # 3. Iniciar worker en segundo plano&#10;        self.worker = STLWorker(hgt_path)&#10;        self.worker.progress.connect(self.progress_dlg.update_progress)&#10;        self.worker.finished.connect(self._on_generation_finished)&#10;        self.worker.start()&#10;&#10;    def _on_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Modelo generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;&#10;    def _generate_full_map(self):&#10;        # Método para generar todo el mapa de Ecuador&#10;        # 1. Volver al menú principal y mostrar progreso&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;        # 2. Mostrar diálogo de progreso para la generación del mapa&#10;        self.progress_dlg = ProgressDialog(&quot;Generando mapa 3D de Ecuador...&quot;)&#10;        self.progress_dlg.setWindowTitle(&quot;Generando mapa 3D de Ecuador&quot;)&#10;        self.progress_dlg.show()&#10;&#10;        # 3. Iniciar worker en segundo plano para la generación del mapa&#10;        self.worker = STLWorker(generate_full_map=True)&#10;        self.worker.progress.connect(self.progress_dlg.update_progress)&#10;        self.worker.finished.connect(self._on_full_map_generation_finished)&#10;        self.worker.start()&#10;&#10;    def _on_full_map_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Mapa generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el mapa STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D del mapa generado&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/map_selector_widget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/map_selector_widget.py" />
              <option name="originalContent" value="from typing import Callable, List, Tuple&#10;from PyQt6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QLabel&#10;from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas&#10;from matplotlib.figure import Figure&#10;from matplotlib.patches import Rectangle&#10;import geopandas as gpd&#10;from core.hgt_utils import find_hgt_files&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;class MapSelectorWidget(QWidget):&#10;    def __init__(self, on_selected: Callable[[str], None], on_back: Callable[[], None], hgt_root=None):&#10;        super().__init__()&#10;        self.on_selected = on_selected&#10;        self.hgt_root = hgt_root&#10;        top = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver&quot;)&#10;        top.addWidget(self.back_btn)&#10;        self.title = QLabel(&quot;Selecciona una zona HGT (clic)&quot;)&#10;        top.addWidget(self.title)&#10;        top.addStretch()&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(top)&#10;&#10;        self.fig = Figure(figsize=(10, 6), tight_layout=True)&#10;        self.canvas = FigureCanvas(self.fig)&#10;        layout.addWidget(self.canvas)&#10;        self.ax = self.fig.add_subplot(111)&#10;        self.ax.set_title(&quot;Ecuador y tiles HGT&quot;)&#10;        self.ax.set_xlabel(&quot;Longitud&quot;)&#10;        self.ax.set_ylabel(&quot;Latitud&quot;)&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;&#10;        self.rectangles: List[Tuple[Rectangle, dict]] = []&#10;        self.canvas.mpl_connect(&quot;pick_event&quot;, self._on_pick)&#10;        self.back_btn.clicked.connect(on_back)&#10;&#10;    def load(self):&#10;        self.ax.clear()&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;        # Ecuador boundary&#10;        gp = get_ecuador_geojson()&#10;        if gp:&#10;            gdf = gpd.read_file(gp)&#10;            gdf.boundary.plot(ax=self.ax, color=&quot;green&quot;, linewidth=2)&#10;&#10;        # HGT tiles&#10;        files = find_hgt_files(self.hgt_root, only_ecuador=True)&#10;        if not files:&#10;            self.ax.set_title(&quot;No se encontraron HGT en Ecuador&quot;)&#10;            self.canvas.draw()&#10;            return&#10;&#10;        lats = [f[&quot;lat&quot;] for f in files]&#10;        lons = [f[&quot;lon&quot;] for f in files]&#10;        self.ax.set_xlim(min(lons)-1, max(lons)+1)&#10;        self.ax.set_ylim(min(lats)-1, max(lats)+1)&#10;&#10;        self.rectangles.clear()&#10;        for f in files:&#10;            rect = Rectangle((f['lon'], f['lat']), 1, 1, edgecolor='black',&#10;                             facecolor='lightgray', alpha=0.7, picker=True)&#10;            self.ax.add_patch(rect)&#10;            self.ax.text(f['lon']+0.5, f['lat']+0.5, f['name'], ha='center', va='center', fontsize=7)&#10;            self.rectangles.append((rect, f))&#10;&#10;        self.canvas.draw()&#10;&#10;    def _on_pick(self, event):&#10;        artist = event.artist&#10;        for rect, info in self.rectangles:&#10;            if artist == rect:&#10;                self.on_selected(info[&quot;path&quot;])&#10;                break" />
              <option name="updatedContent" value="from typing import Callable, List, Tuple&#10;from PyQt6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QLabel&#10;from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas&#10;from matplotlib.figure import Figure&#10;from matplotlib.patches import Rectangle&#10;import geopandas as gpd&#10;from core.hgt_utils import find_hgt_files&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;from core.paths import Paths&#10;&#10;class MapSelectorWidget(QWidget):&#10;    def __init__(self, on_selected: Callable[[str], None], on_back: Callable[[], None], hgt_root=None):&#10;        super().__init__()&#10;        self.on_selected = on_selected&#10;        self.hgt_root = hgt_root&#10;        top = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver&quot;)&#10;        top.addWidget(self.back_btn)&#10;        self.title = QLabel(&quot;Selecciona una zona HGT (clic)&quot;)&#10;        top.addWidget(self.title)&#10;        top.addStretch()&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(top)&#10;&#10;        self.fig = Figure(figsize=(10, 6), tight_layout=True)&#10;        self.canvas = FigureCanvas(self.fig)&#10;        layout.addWidget(self.canvas)&#10;        self.ax = self.fig.add_subplot(111)&#10;        self.ax.set_title(&quot;Ecuador y tiles HGT&quot;)&#10;        self.ax.set_xlabel(&quot;Longitud&quot;)&#10;        self.ax.set_ylabel(&quot;Latitud&quot;)&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;&#10;        self.rectangles: List[Tuple[Rectangle, dict]] = []&#10;        self.canvas.mpl_connect(&quot;pick_event&quot;, self._on_pick)&#10;        self.back_btn.clicked.connect(on_back)&#10;&#10;    def load(self):&#10;        self.ax.clear()&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;        &#10;        # Mostrar ruta actual de búsqueda HGT&#10;        print(f&quot;Buscando archivos HGT en: {self.hgt_root or Paths.hgt_dir}&quot;)&#10;        &#10;        # Ecuador boundary&#10;        gp = get_ecuador_geojson()&#10;        if gp:&#10;            print(f&quot;Archivo GeoJSON cargado: {gp}&quot;)&#10;            try:&#10;                gdf = gpd.read_file(gp)&#10;                gdf.boundary.plot(ax=self.ax, color=&quot;green&quot;, linewidth=2)&#10;            except Exception as e:&#10;                print(f&quot;Error al cargar GeoJSON: {e}&quot;)&#10;                self.ax.set_title(&quot;Error al cargar límites de Ecuador&quot;)&#10;                self.canvas.draw()&#10;                return&#10;&#10;        # HGT tiles&#10;        try:&#10;            files = find_hgt_files(self.hgt_root, only_ecuador=True)&#10;            print(f&quot;Archivos HGT encontrados: {len(files)}&quot;)&#10;            &#10;            if not files:&#10;                print(&quot;No se encontraron archivos HGT en Ecuador&quot;)&#10;                self.ax.set_title(&quot;No se encontraron HGT en Ecuador&quot;)&#10;                self.canvas.draw()&#10;                return&#10;                &#10;        except Exception as e:&#10;            print(f&quot;Error al buscar archivos HGT: {e}&quot;)&#10;            self.ax.set_title(f&quot;Error al buscar archivos HGT: {str(e)}&quot;)&#10;            self.canvas.draw()&#10;            return&#10;&#10;        lats = [f[&quot;lat&quot;] for f in files]&#10;        lons = [f[&quot;lon&quot;] for f in files]&#10;        self.ax.set_xlim(min(lons)-1, max(lons)+1)&#10;        self.ax.set_ylim(min(lats)-1, max(lats)+1)&#10;&#10;        self.rectangles.clear()&#10;        for f in files:&#10;            rect = Rectangle((f['lon'], f['lat']), 1, 1, edgecolor='black',&#10;                             facecolor='lightgray', alpha=0.7, picker=True)&#10;            self.ax.add_patch(rect)&#10;            self.ax.text(f['lon']+0.5, f['lat']+0.5, f['name'], ha='center', va='center', fontsize=7)&#10;            self.rectangles.append((rect, f))&#10;&#10;        self.canvas.draw()&#10;&#10;    def _on_pick(self, event):&#10;        artist = event.artist&#10;        for rect, info in self.rectangles:&#10;            if artist == rect:&#10;                self.on_selected(info[&quot;path&quot;])&#10;                break" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/progress_dialog.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/progress_dialog.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QPushButton&#10;from PyQt6.QtCore import Qt&#10;&#10;class ProgressDialog(QDialog):&#10;    def __init__(self, title=&quot;Procesando...&quot;):&#10;        super().__init__()&#10;        self.setWindowTitle(title)&#10;        self.setModal(True)&#10;        self.setFixedSize(420, 140)&#10;        layout = QVBoxLayout(self)&#10;        self.label = QLabel(&quot;Iniciando...&quot;)&#10;        self.bar = QProgressBar()&#10;        self.bar.setRange(0, 100)&#10;        self.cancel_btn = QPushButton(&quot;Cancelar&quot;)&#10;        layout.addWidget(self.label)&#10;        layout.addWidget(self.bar)&#10;        layout.addWidget(self.cancel_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;    def update_progress(self, val: int, text: str = &quot;&quot;):&#10;        self.bar.setValue(val)&#10;        if text:&#10;            self.label.setText(text)" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QPushButton&#13;&#10;from PyQt6.QtCore import Qt, QTimer&#13;&#10;&#13;&#10;class ProgressDialog(QDialog):&#13;&#10;    def __init__(self, title=&quot;Procesando...&quot;):&#13;&#10;        super().__init__()&#13;&#10;        self.setWindowTitle(title)&#13;&#10;        self.setModal(True)&#13;&#10;        self.setFixedSize(480, 180)&#13;&#10;        &#13;&#10;        layout = QVBoxLayout(self)&#13;&#10;        &#13;&#10;        # Título más grande y visible&#13;&#10;        self.title_label = QLabel(title)&#13;&#10;        self.title_label.setStyleSheet(&quot;font-size: 14pt; font-weight: bold;&quot;)&#13;&#10;        layout.addWidget(self.title_label)&#13;&#10;        &#13;&#10;        # Etiqueta de estado&#13;&#10;        self.label = QLabel(&quot;Iniciando proceso...&quot;)&#13;&#10;        self.label.setStyleSheet(&quot;font-size: 11pt;&quot;)&#13;&#10;        layout.addWidget(self.label)&#13;&#10;        &#13;&#10;        # Barra de progreso más grande&#13;&#10;        self.bar = QProgressBar()&#13;&#10;        self.bar.setRange(0, 100)&#13;&#10;        self.bar.setTextVisible(True)&#13;&#10;        self.bar.setMinimumHeight(25)&#13;&#10;        layout.addWidget(self.bar)&#13;&#10;        &#13;&#10;        # Botón de cancelar&#13;&#10;        self.cancel_btn = QPushButton(&quot;Cancelar&quot;)&#13;&#10;        self.cancel_btn.setFixedWidth(100)&#13;&#10;        layout.addWidget(self.cancel_btn, alignment=Qt.AlignmentFlag.AlignRight)&#13;&#10;        &#13;&#10;        # Para animación en caso de que no haya actualizaciones&#13;&#10;        self.timer = QTimer()&#13;&#10;        self.timer.timeout.connect(self._pulse)&#13;&#10;        self.timer.start(150)&#13;&#10;        &#13;&#10;    def _pulse(self):&#13;&#10;        # Solo anima si no hay progreso definido (valor = 0)&#13;&#10;        if self.bar.value() == 0:&#13;&#10;            v = (self.bar.value() + 1) % 100&#13;&#10;            self.bar.setValue(v)&#13;&#10;    &#13;&#10;    def update_progress(self, val: int, text: str = &quot;&quot;):&#13;&#10;        # Detener animación si recibimos valor real&#13;&#10;        if val &gt; 0:&#13;&#10;            self.timer.stop()&#13;&#10;            &#13;&#10;        self.bar.setValue(val)&#13;&#10;        if text:&#13;&#10;            self.label.setText(text)&#13;&#10;            &#13;&#10;    def closeEvent(self, event):&#13;&#10;        self.timer.stop()&#13;&#10;        super().closeEvent(event)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/viewer_3d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/viewer_3d.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel&#10;from pyvistaqt import QtInteractor&#10;import pyvista as pv&#10;from pathlib import Path&#10;&#10;class Viewer3D(QWidget):&#10;    def __init__(self, back_cb):&#10;        super().__init__()&#10;        self.back_cb = back_cb&#10;        self.plotter = QtInteractor(self)&#10;        self.info = QLabel(&quot;&quot;)&#10;        btns = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver al menú&quot;)&#10;        btns.addWidget(self.back_btn)&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(btns)&#10;        layout.addWidget(self.plotter.interactor)&#10;        layout.addWidget(self.info)&#10;        self.back_btn.clicked.connect(self.back_cb)&#10;&#10;    def load_stl(self, stl_path: str):&#10;        self.plotter.clear()&#10;        mesh = pv.read(stl_path)&#10;        self.plotter.add_mesh(mesh, cmap=&quot;terrain&quot;, show_edges=False, lighting=True)&#10;        self.plotter.enable_eye_dome_lighting()&#10;        self.plotter.show_grid()&#10;        self.plotter.reset_camera()&#10;        self.info.setText(f&quot;Archivo: {Path(stl_path).name}&quot;)" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, &#13;&#10;                         QLabel, QFileDialog, QSizePolicy, QFrame, QComboBox)&#13;&#10;from PyQt6.QtCore import Qt&#13;&#10;from pyvistaqt import QtInteractor&#13;&#10;import pyvista as pv&#13;&#10;from pathlib import Path&#13;&#10;import os&#13;&#10;from core.paths import Paths&#13;&#10;&#13;&#10;class Viewer3D(QWidget):&#13;&#10;    def __init__(self, back_cb):&#13;&#10;        super().__init__()&#13;&#10;        self.back_cb = back_cb&#13;&#10;        self.current_file = None&#13;&#10;        &#13;&#10;        # Crear layout principal&#13;&#10;        main_layout = QVBoxLayout(self)&#13;&#10;        main_layout.setContentsMargins(10, 10, 10, 10)&#13;&#10;        main_layout.setSpacing(10)&#13;&#10;        &#13;&#10;        # Panel superior con controles&#13;&#10;        top_panel = QFrame()&#13;&#10;        top_panel.setFrameShape(QFrame.Shape.StyledPanel)&#13;&#10;        top_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)&#13;&#10;        &#13;&#10;        top_layout = QHBoxLayout(top_panel)&#13;&#10;        &#13;&#10;        # Botón de volver al menú&#13;&#10;        self.back_btn = QPushButton(&quot;← Volver al Menú&quot;)&#13;&#10;        self.back_btn.setMinimumWidth(150)&#13;&#10;        self.back_btn.clicked.connect(self.back_cb)&#13;&#10;        &#13;&#10;        # Información del archivo&#13;&#10;        self.info = QLabel(&quot;&quot;)&#13;&#10;        self.info.setStyleSheet(&quot;font-size: 12pt; font-weight: bold;&quot;)&#13;&#10;        self.info.setAlignment(Qt.AlignmentFlag.AlignCenter)&#13;&#10;        &#13;&#10;        # Controles adicionales&#13;&#10;        self.save_btn = QPushButton(&quot;Guardar STL como...&quot;)&#13;&#10;        self.save_btn.setMinimumWidth(150)&#13;&#10;        self.save_btn.clicked.connect(self._save_stl)&#13;&#10;        &#13;&#10;        # Selector de estilo de visualización&#13;&#10;        self.view_style = QComboBox()&#13;&#10;        self.view_style.addItems([&quot;Terreno&quot;, &quot;Sólido&quot;, &quot;Wireframe&quot;, &quot;Puntos&quot;])&#13;&#10;        self.view_style.currentIndexChanged.connect(self._change_view_style)&#13;&#10;        &#13;&#10;        # Agregar widgets al panel superior&#13;&#10;        top_layout.addWidget(self.back_btn)&#13;&#10;        top_layout.addWidget(self.info, 1)  # 1 = stretch factor&#13;&#10;        top_layout.addWidget(self.view_style)&#13;&#10;        top_layout.addWidget(self.save_btn)&#13;&#10;        &#13;&#10;        # Panel de visualización 3D&#13;&#10;        viewer_panel = QFrame()&#13;&#10;        viewer_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#13;&#10;        viewer_layout = QVBoxLayout(viewer_panel)&#13;&#10;        viewer_layout.setContentsMargins(0, 0, 0, 0)&#13;&#10;        &#13;&#10;        # Inicializar plotter de PyVista&#13;&#10;        self.plotter = QtInteractor(self)&#13;&#10;        viewer_layout.addWidget(self.plotter.interactor)&#13;&#10;        &#13;&#10;        # Panel inferior con información adicional&#13;&#10;        bottom_panel = QFrame()&#13;&#10;        bottom_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)&#13;&#10;        bottom_layout = QHBoxLayout(bottom_panel)&#13;&#10;        &#13;&#10;        self.model_info = QLabel(&quot;&quot;)&#13;&#10;        self.model_info.setStyleSheet(&quot;font-style: italic;&quot;)&#13;&#10;        bottom_layout.addWidget(self.model_info)&#13;&#10;        &#13;&#10;        # Agregar paneles al layout principal&#13;&#10;        main_layout.addWidget(top_panel)&#13;&#10;        main_layout.addWidget(viewer_panel, 1)  # 1 = stretch factor&#13;&#10;        main_layout.addWidget(bottom_panel)&#13;&#10;        &#13;&#10;    def load_stl(self, stl_path: str):&#13;&#10;        &quot;&quot;&quot;Carga un archivo STL y lo muestra en el visualizador 3D&quot;&quot;&quot;&#13;&#10;        self.current_file = stl_path&#13;&#10;        self.plotter.clear()&#13;&#10;        &#13;&#10;        try:&#13;&#10;            # Cargar mesh&#13;&#10;            mesh = pv.read(stl_path)&#13;&#10;            &#13;&#10;            # Mostrar el modelo con el estilo por defecto (Terreno)&#13;&#10;            self._display_mesh(mesh, style=&quot;terrain&quot;)&#13;&#10;            &#13;&#10;            # Actualizar información&#13;&#10;            file_name = Path(stl_path).name&#13;&#10;            self.info.setText(f&quot;Modelo: {file_name}&quot;)&#13;&#10;            &#13;&#10;            # Mostrar estadísticas del modelo&#13;&#10;            n_points = mesh.n_points&#13;&#10;            n_cells = mesh.n_cells&#13;&#10;            self.model_info.setText(f&quot;Puntos: {n_points:,} | Caras: {n_cells:,} | Archivo: {os.path.abspath(stl_path)}&quot;)&#13;&#10;            &#13;&#10;        except Exception as e:&#13;&#10;            self.info.setText(f&quot;Error al cargar el modelo: {str(e)}&quot;)&#13;&#10;            self.model_info.setText(&quot;&quot;)&#13;&#10;    &#13;&#10;    def _change_view_style(self, index):&#13;&#10;        &quot;&quot;&quot;Cambia el estilo de visualización del modelo&quot;&quot;&quot;&#13;&#10;        if self.current_file is None:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # Volver a cargar el mesh&#13;&#10;        mesh = pv.read(self.current_file)&#13;&#10;        &#13;&#10;        # Aplicar el estilo seleccionado&#13;&#10;        styles = [&quot;terrain&quot;, &quot;default&quot;, &quot;wireframe&quot;, &quot;points&quot;]&#13;&#10;        selected_style = styles[index] if index &lt; len(styles) else &quot;terrain&quot;&#13;&#10;        &#13;&#10;        self._display_mesh(mesh, style=selected_style)&#13;&#10;    &#13;&#10;    def _display_mesh(self, mesh, style=&quot;terrain&quot;):&#13;&#10;        &quot;&quot;&quot;Muestra un mesh con el estilo especificado&quot;&quot;&quot;&#13;&#10;        self.plotter.clear()&#13;&#10;        &#13;&#10;        if style == &quot;terrain&quot;:&#13;&#10;            # Estilo de terreno con colores según elevación&#13;&#10;            self.plotter.add_mesh(mesh, cmap=&quot;terrain&quot;, show_edges=False, lighting=True)&#13;&#10;            self.plotter.enable_eye_dome_lighting()&#13;&#10;        elif style == &quot;wireframe&quot;:&#13;&#10;            # Estilo de wireframe&#13;&#10;            self.plotter.add_mesh(mesh, style=&quot;wireframe&quot;, color=&quot;black&quot;, line_width=1)&#13;&#10;        elif style == &quot;points&quot;:&#13;&#10;            # Estilo de puntos&#13;&#10;            self.plotter.add_mesh(mesh, style=&quot;points&quot;, color=&quot;blue&quot;, point_size=5)&#13;&#10;        else:&#13;&#10;            # Estilo por defecto (sólido)&#13;&#10;            self.plotter.add_mesh(mesh, color=&quot;lightgray&quot;, show_edges=True)&#13;&#10;        &#13;&#10;        self.plotter.show_grid()&#13;&#10;        self.plotter.reset_camera()&#13;&#10;        &#13;&#10;    def _save_stl(self):&#13;&#10;        &quot;&quot;&quot;Guarda el modelo STL actual en una nueva ubicación&quot;&quot;&quot;&#13;&#10;        if self.current_file is None:&#13;&#10;            return&#13;&#10;            &#13;&#10;        original_filename = Path(self.current_file).stem&#13;&#10;        &#13;&#10;        # Mostrar diálogo para guardar archivo&#13;&#10;        file_path, _ = QFileDialog.getSaveFileName(&#13;&#10;            self,&#13;&#10;            &quot;Guardar STL como&quot;,&#13;&#10;            str(Paths.stl_dir / f&quot;{original_filename}_copy.stl&quot;),&#13;&#10;            &quot;STL Files (*.stl)&quot;&#13;&#10;        )&#13;&#10;        &#13;&#10;        if file_path:&#13;&#10;            try:&#13;&#10;                # Leer el mesh original y guardarlo en la nueva ubicación&#13;&#10;                mesh = pv.read(self.current_file)&#13;&#10;                mesh.save(file_path)&#13;&#10;                &#13;&#10;                # Actualizar información&#13;&#10;                self.model_info.setText(f&quot;Guardado como: {file_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                self.model_info.setText(f&quot;Error al guardar: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/workers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/workers.py" />
              <option name="originalContent" value="from PyQt6.QtCore import QThread, pyqtSignal&#10;from core.stl_generator import generate_stl_from_hgt&#10;&#10;class STLWorker(QThread):&#10;    progress = pyqtSignal(int, str)&#10;    finished = pyqtSignal(bool, str, str)  # success, stl_path, error_msg&#10;&#10;    def __init__(self, hgt_path: str, out_dir: str | None = None):&#10;        super().__init__()&#10;        self.hgt_path = hgt_path&#10;        self.out_dir = out_dir&#10;&#10;    def run(self):&#10;        try:&#10;            def cb(val, msg):&#10;                self.progress.emit(val, msg)&#10;            stl_path = generate_stl_from_hgt(self.hgt_path, self.out_dir, cb)&#10;            self.finished.emit(True, stl_path, &quot;&quot;)&#10;        except Exception as e:&#10;            self.finished.emit(False, &quot;&quot;, str(e))" />
              <option name="updatedContent" value="from PyQt6.QtCore import QThread, pyqtSignal&#10;from core.stl_generator import generate_stl_from_hgt, generate_full_ecuador_map&#10;from core.hgt_utils import find_hgt_files&#10;&#10;class STLWorker(QThread):&#10;    progress = pyqtSignal(int, str)&#10;    finished = pyqtSignal(bool, str, str)  # success, stl_path, error_msg&#10;&#10;    def __init__(self, hgt_path: str = None, out_dir: str = None, generate_full_map: bool = False):&#10;        super().__init__()&#10;        self.hgt_path = hgt_path&#10;        self.out_dir = out_dir&#10;        self.generate_full_map = generate_full_map&#10;&#10;    def run(self):&#10;        try:&#10;            def cb(val, msg):&#10;                self.progress.emit(val, msg)&#10;            &#10;            if self.generate_full_map:&#10;                # Generar el mapa completo de Ecuador&#10;                stl_path = generate_full_ecuador_map(progress_callback=cb)&#10;            else:&#10;                # Generar un solo tile HGT&#10;                stl_path = generate_stl_from_hgt(self.hgt_path, self.out_dir, cb)&#10;                &#10;            self.finished.emit(True, stl_path, &quot;&quot;)&#10;        except Exception as e:&#10;            self.finished.emit(False, &quot;&quot;, str(e))" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>