<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/ecuador_boundary.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/ecuador_boundary.py" />
              <option name="originalContent" value="import os&#10;import requests&#10;from pathlib import Path&#10;from core.paths import Paths&#10;&#10;ECU_URL = &quot;https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries/ECU.geojson&quot;&#10;&#10;def get_ecuador_geojson():&#10;    Paths.ensure()&#10;    out_path = Paths.boundaries_dir / &quot;ecuador.geojson&quot;&#10;    if not out_path.exists():&#10;        print(&quot;Descargando el contorno de Ecuador...&quot;)&#10;        r = requests.get(ECU_URL, timeout=30)&#10;        if r.status_code == 200:&#10;            out_path.write_bytes(r.content)&#10;            print(&quot;GeoJSON de Ecuador guardado en&quot;, out_path)&#10;        else:&#10;            print(&quot;No se pudo descargar el GeoJSON de Ecuador.&quot;)&#10;            return None&#10;    return str(out_path)" />
              <option name="updatedContent" value="import os&#10;import requests&#10;from pathlib import Path&#10;import json&#10;import time&#10;from core.paths import Paths&#10;&#10;# Múltiples URLs para mayor confiabilidad&#10;ECU_URLS = [&#10;    &quot;https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries/ECU.geojson&quot;,&#10;    &quot;https://raw.githubusercontent.com/johan/world.geo.json/master/countries/ECU.geo.json&quot;&#10;]&#10;&#10;# GeoJSON básico de Ecuador como respaldo (simplificado)&#10;BASIC_ECUADOR_GEOJSON = {&#10;    &quot;type&quot;: &quot;FeatureCollection&quot;,&#10;    &quot;features&quot;: [{&#10;        &quot;type&quot;: &quot;Feature&quot;,&#10;        &quot;properties&quot;: {&quot;name&quot;: &quot;Ecuador&quot;},&#10;        &quot;geometry&quot;: {&#10;            &quot;type&quot;: &quot;Polygon&quot;,&#10;            &quot;coordinates&quot;: [[&#10;                [-81.0, -5.0], [-81.0, 1.5], &#10;                [-75.0, 1.5], [-75.0, -5.0], &#10;                [-81.0, -5.0]&#10;            ]]&#10;        }&#10;    }]&#10;}&#10;&#10;def get_ecuador_geojson():&#10;    &quot;&quot;&quot;&#10;    Obtiene el archivo GeoJSON de Ecuador.&#10;    Primero intenta usar un archivo local, luego descarga desde internet,&#10;    y finalmente usa un contorno básico como respaldo si todo lo demás falla.&#10;    &quot;&quot;&quot;&#10;    Paths.ensure()&#10;    out_path = Paths.ecuador_geojson&#10;    &#10;    # 1. Verificar si el archivo ya existe localmente&#10;    if out_path.exists():&#10;        print(f&quot;Usando archivo GeoJSON existente: {out_path}&quot;)&#10;        return str(out_path)&#10;    &#10;    print(&quot;El archivo GeoJSON de Ecuador no existe localmente, intentando descargar...&quot;)&#10;    &#10;    # 2. Intentar descargar de múltiples URLs&#10;    for i, url in enumerate(ECU_URLS):&#10;        try:&#10;            print(f&quot;Intentando descargar desde {url}...&quot;)&#10;            r = requests.get(url, timeout=10)&#10;            if r.status_code == 200:&#10;                out_path.write_bytes(r.content)&#10;                print(f&quot;GeoJSON de Ecuador guardado en {out_path}&quot;)&#10;                return str(out_path)&#10;            else:&#10;                print(f&quot;Error al descargar (HTTP {r.status_code})&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error al descargar: {e}&quot;)&#10;            if i &lt; len(ECU_URLS) - 1:  # Si no es el último intento&#10;                print(&quot;Intentando con URL alternativa...&quot;)&#10;                time.sleep(1)  # Pequeña pausa antes del siguiente intento&#10;    &#10;    # 3. Usar GeoJSON básico como último recurso&#10;    print(&quot;Usando contorno básico de Ecuador como respaldo&quot;)&#10;    with open(out_path, 'w') as f:&#10;        json.dump(BASIC_ECUADOR_GEOJSON, f)&#10;    &#10;    return str(out_path)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/hgt_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/hgt_utils.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import numpy as np&#10;import geopandas as gpd&#10;from shapely.geometry import box&#10;from core.paths import Paths&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;HGT_PATTERN = re.compile(r'([NS])(\d{2})([EW])(\d{3})\.hgt$', re.IGNORECASE)&#10;&#10;def parse_hgt_filename(fname: str):&#10;    m = HGT_PATTERN.search(os.path.basename(fname))&#10;    if not m:&#10;        return None&#10;    lat = int(m.group(2)) * (1 if m.group(1).upper() == &quot;N&quot; else -1)&#10;    lon = int(m.group(4)) * (1 if m.group(3).upper() == &quot;E&quot; else -1)&#10;    return lat, lon&#10;&#10;def find_hgt_files(root_dir=None, only_ecuador=True):&#10;    if root_dir is None:&#10;        root_dir = str(Paths.hgt_dir)&#10;    hgt_files = []&#10;    for dirpath, _, filenames in os.walk(root_dir):&#10;        for fn in filenames:&#10;            if fn.lower().endswith(&quot;.hgt&quot;):&#10;                coords = parse_hgt_filename(fn)&#10;                if coords:&#10;                    hgt_files.append({&#10;                        &quot;path&quot;: os.path.join(dirpath, fn),&#10;                        &quot;lat&quot;: coords[0],&#10;                        &quot;lon&quot;: coords[1],&#10;                        &quot;name&quot;: fn&#10;                    })&#10;    if only_ecuador and hgt_files:&#10;        geojson = get_ecuador_geojson()&#10;        if geojson:&#10;            gdf = gpd.read_file(geojson)&#10;            def in_ec(lat, lon):&#10;                tile = box(lon, lat, lon+1, lat+1)&#10;                return gdf.intersects(tile).any()&#10;            hgt_files = [f for f in hgt_files if in_ec(f[&quot;lat&quot;], f[&quot;lon&quot;])]&#10;    return hgt_files&#10;&#10;def read_hgt_array(hgt_path: str):&#10;    with open(hgt_path, &quot;rb&quot;) as f:&#10;        data = np.fromfile(f, dtype=&quot;&gt;i2&quot;)&#10;    size = int(np.sqrt(data.size))&#10;    if size * size != data.size:&#10;        raise ValueError(f&quot;Archivo HGT no cuadrado: {hgt_path}&quot;)&#10;    Z = data.reshape((size, size)).astype(float)&#10;    # manejar voids SRTM&#10;    void_mask = Z &lt;= -32000&#10;    if void_mask.any():&#10;        Z[void_mask] = np.nan&#10;        Z = np.where(np.isnan(Z), np.nanmin(Z), Z)&#10;    return Z" />
              <option name="updatedContent" value="import os&#10;import re&#10;import numpy as np&#10;import geopandas as gpd&#10;from shapely.geometry import box&#10;from core.paths import Paths&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;HGT_PATTERN = re.compile(r'([NS])(\d{2})([EW])(\d{3})\.hgt$', re.IGNORECASE)&#10;&#10;def parse_hgt_filename(fname: str):&#10;    m = HGT_PATTERN.search(os.path.basename(fname))&#10;    if not m:&#10;        return None&#10;    lat = int(m.group(2)) * (1 if m.group(1).upper() == &quot;N&quot; else -1)&#10;    lon = int(m.group(4)) * (1 if m.group(3).upper() == &quot;E&quot; else -1)&#10;    return lat, lon&#10;&#10;def find_hgt_files(root_dir=None, only_ecuador=True):&#10;    &quot;&quot;&quot;&#10;    Busca archivos HGT en el directorio especificado.&#10;    &#10;    Args:&#10;        root_dir: Directorio donde buscar archivos HGT. Si es None, usa Paths.hgt_dir&#10;        only_ecuador: Si True, filtra solo archivos que intersectan con Ecuador&#10;        &#10;    Returns:&#10;        Lista de diccionarios con información de los archivos HGT encontrados&#10;    &quot;&quot;&quot;&#10;    if root_dir is None:&#10;        root_dir = str(Paths.hgt_dir)&#10;    &#10;    print(f&quot;Buscando archivos HGT en: {root_dir}&quot;)&#10;    &#10;    hgt_files = []&#10;    for dirpath, _, filenames in os.walk(root_dir):&#10;        for fn in filenames:&#10;            if fn.lower().endswith(&quot;.hgt&quot;):&#10;                coords = parse_hgt_filename(fn)&#10;                if coords:&#10;                    hgt_files.append({&#10;                        &quot;path&quot;: os.path.join(dirpath, fn),&#10;                        &quot;lat&quot;: coords[0],&#10;                        &quot;lon&quot;: coords[1],&#10;                        &quot;name&quot;: fn&#10;                    })&#10;    &#10;    print(f&quot;Total de archivos HGT encontrados: {len(hgt_files)}&quot;)&#10;    &#10;    # Filtrar por Ecuador solo si se especifica y hay archivos&#10;    if only_ecuador and hgt_files:&#10;        try:&#10;            geojson = get_ecuador_geojson()&#10;            if not geojson:&#10;                print(&quot;No se pudo obtener el GeoJSON de Ecuador. Mostrando todos los archivos HGT.&quot;)&#10;                return hgt_files&#10;                &#10;            print(f&quot;Filtrando archivos HGT usando: {geojson}&quot;)&#10;            gdf = gpd.read_file(geojson)&#10;            &#10;            def in_ec(lat, lon):&#10;                tile = box(lon, lat, lon+1, lat+1)&#10;                return gdf.intersects(tile).any()&#10;                &#10;            ecuador_files = [f for f in hgt_files if in_ec(f[&quot;lat&quot;], f[&quot;lon&quot;])]&#10;            print(f&quot;Archivos HGT en Ecuador: {len(ecuador_files)}&quot;)&#10;            return ecuador_files&#10;            &#10;        except Exception as e:&#10;            print(f&quot;Error al filtrar archivos por Ecuador: {e}&quot;)&#10;            # En caso de error, retorna todos los archivos&#10;            return hgt_files&#10;    &#10;    return hgt_files&#10;&#10;def read_hgt_array(hgt_path: str):&#10;    with open(hgt_path, &quot;rb&quot;) as f:&#10;        data = np.fromfile(f, dtype=&quot;&gt;i2&quot;)&#10;    size = int(np.sqrt(data.size))&#10;    if size * size != data.size:&#10;        raise ValueError(f&quot;Archivo HGT no cuadrado: {hgt_path}&quot;)&#10;    Z = data.reshape((size, size)).astype(float)&#10;    # manejar voids SRTM&#10;    void_mask = Z &lt;= -32000&#10;    if void_mask.any():&#10;        Z[void_mask] = np.nan&#10;        Z = np.where(np.isnan(Z), np.nanmin(Z), Z)&#10;    return Z" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/paths.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/paths.py" />
              <option name="originalContent" value="from pathlib import Path&#10;import os&#10;&#10;class Paths:&#10;    project_root = Path(__file__).resolve().parents[2]&#10;&#10;    # Carpetas de datos de entrada&#10;    data_dir = project_root / &quot;data&quot;&#10;    hgt_dir = data_dir / &quot;hgt&quot;&#10;    boundaries_dir = data_dir / &quot;boundaries&quot;&#10;&#10;    # Carpetas de salida&#10;    outputs_dir = project_root / &quot;outputs&quot;&#10;    stl_dir = outputs_dir / &quot;stl&quot;&#10;    previews_dir = outputs_dir / &quot;previews&quot;&#10;&#10;    # Archivos específicos&#10;    ecuador_geojson = boundaries_dir / &quot;ecuador.geojson&quot;&#10;&#10;    @staticmethod&#10;    def ensure():&#10;        &quot;&quot;&quot;Asegura que todas las carpetas necesarias existan&quot;&quot;&quot;&#10;        for p in [&#10;            Paths.data_dir,&#10;            Paths.hgt_dir,&#10;            Paths.boundaries_dir,&#10;            Paths.outputs_dir,&#10;            Paths.stl_dir,&#10;            Paths.previews_dir&#10;        ]:&#10;            p.mkdir(parents=True, exist_ok=True)&#10;&#10;    @staticmethod&#10;    def update_stl_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de STL&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;&#10;        Paths.stl_dir = new_path&#10;        Paths.stl_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.stl_dir&#10;&#10;    @staticmethod&#10;    def update_hgt_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de HGT&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;&#10;        Paths.hgt_dir = new_path&#10;        Paths.hgt_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.hgt_dir&#10;" />
              <option name="updatedContent" value="from pathlib import Path&#10;import os&#10;&#10;class Paths:&#10;    # Corregir el cálculo de la ruta raíz del proyecto&#10;    project_root = Path(__file__).resolve().parents[1]  # Cambiado de parents[2] a parents[1]&#10;    &#10;    # Carpetas de datos de entrada&#10;    data_dir = project_root / &quot;data&quot;&#10;    hgt_dir = data_dir / &quot;hgt&quot;&#10;    boundaries_dir = data_dir / &quot;boundaries&quot;&#10;    &#10;    # Carpetas de salida&#10;    outputs_dir = project_root / &quot;outputs&quot;&#10;    stl_dir = outputs_dir / &quot;stl&quot;&#10;    previews_dir = outputs_dir / &quot;previews&quot;&#10;    &#10;    # Archivos específicos&#10;    ecuador_geojson = boundaries_dir / &quot;ecuador.geojson&quot;&#10;&#10;    @staticmethod&#10;    def ensure():&#10;        &quot;&quot;&quot;Asegura que todas las carpetas necesarias existan&quot;&quot;&quot;&#10;        for p in [&#10;            Paths.data_dir, &#10;            Paths.hgt_dir, &#10;            Paths.boundaries_dir, &#10;            Paths.outputs_dir, &#10;            Paths.stl_dir, &#10;            Paths.previews_dir&#10;        ]:&#10;            p.mkdir(parents=True, exist_ok=True)&#10;        &#10;        # Imprimir rutas para diagnóstico&#10;        print(f&quot;Rutas configuradas:&quot;)&#10;        print(f&quot;- Proyecto: {Paths.project_root}&quot;)&#10;        print(f&quot;- Datos HGT: {Paths.hgt_dir}&quot;)&#10;        print(f&quot;- Límites: {Paths.boundaries_dir}&quot;)&#10;        print(f&quot;- Salida STL: {Paths.stl_dir}&quot;)&#10;    &#10;    @staticmethod&#10;    def update_stl_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de STL&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;        &#10;        Paths.stl_dir = new_path&#10;        Paths.stl_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.stl_dir&#10;        &#10;    @staticmethod&#10;    def update_hgt_dir(new_path):&#10;        &quot;&quot;&quot;Actualiza la ruta de la carpeta de HGT&quot;&quot;&quot;&#10;        if not isinstance(new_path, Path):&#10;            new_path = Path(new_path)&#10;            &#10;        Paths.hgt_dir = new_path&#10;        Paths.hgt_dir.mkdir(parents=True, exist_ok=True)&#10;        return Paths.hgt_dir" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/stl_generator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/stl_generator.py" />
              <option name="originalContent" value="from typing import Callable, Optional&#10;from pathlib import Path&#10;import numpy as np&#10;from scipy.ndimage import gaussian_filter&#10;import pyvista as pv&#10;from core.paths import Paths&#10;from core.hgt_utils import read_hgt_array, find_hgt_files&#10;&#10;ProgressCB = Optional[Callable[[int, str], None]]&#10;&#10;def generate_stl_from_hgt(hgt_path: str, out_dir: Optional[str] = None, progress: ProgressCB = None) -&gt; str:&#10;    def p(val, msg):&#10;        if progress: progress(val, msg)&#10;&#10;    Paths.ensure()&#10;    if out_dir is None:&#10;        out_dir = str(Paths.stl_dir)&#10;&#10;    name = Path(hgt_path).stem&#10;    out_path = str(Path(out_dir) / f&quot;{name}_solido.stl&quot;)&#10;&#10;    p(5, &quot;Leyendo HGT...&quot;)&#10;    Z = read_hgt_array(hgt_path)&#10;&#10;    p(20, &quot;Suavizando elevación...&quot;)&#10;    Z = gaussian_filter(Z, sigma=5.0, truncate=2.5)&#10;&#10;    p(30, &quot;Submuestreando...&quot;)&#10;    skip = 6&#10;    Z = Z[::skip, ::skip]&#10;    nx, ny = Z.shape&#10;    x = np.linspace(0, nx - 1, nx)&#10;    y = np.linspace(0, ny - 1, ny)&#10;    X, Y = np.meshgrid(x, y, indexing=&quot;ij&quot;)&#10;&#10;    p(40, &quot;Construyendo base y bordes...&quot;)&#10;    # Escalado vertical y normalización (similar a tu lógica)&#10;    Z_scaled = Z * 0.12&#10;    zmin, zmax = float(np.min(Z_scaled)), float(np.max(Z_scaled))&#10;    rng = zmax - zmin if zmax &gt; zmin else 1.0&#10;    Z_norm = (Z_scaled - zmin) / rng&#10;    compression_factor = 0.6&#10;    Z_comp = np.where(Z_norm &gt; 0.3, 0.3 + (Z_norm - 0.3)*compression_factor, Z_norm)&#10;    Z_scaled = zmin + Z_comp * rng&#10;&#10;    zmin = float(np.min(Z_scaled))&#10;    base_thickness = 20.0&#10;    base_height = zmin - base_thickness&#10;&#10;    # Borde suave hacia la base&#10;    edge_fade = 10&#10;    Z_smooth = Z_scaled.copy()&#10;    for i in range(edge_fade):&#10;        alpha = i / edge_fade&#10;        Z_smooth[i, :]       = np.minimum(Z_smooth[i, :],       base_height + (Z_smooth[i, :]       - base_height) * alpha)&#10;        Z_smooth[-(i+1), :]  = np.minimum(Z_smooth[-(i+1), :],  base_height + (Z_smooth[-(i+1), :]  - base_height) * alpha)&#10;        Z_smooth[:, i]       = np.minimum(Z_smooth[:, i],       base_height + (Z_smooth[:, i]       - base_height) * alpha)&#10;        Z_smooth[:, -(i+1)]  = np.minimum(Z_smooth[:, -(i+1)],  base_height + (Z_smooth[:, -(i+1)]  - base_height) * alpha)&#10;&#10;    p(55, &quot;Construyendo malla sólida...&quot;)&#10;    points = []&#10;    # superficie&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], Z_smooth[i, j]])&#10;    # base&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], base_height])&#10;&#10;    offset = nx * ny&#10;    faces = []&#10;    # top y base&#10;    for i in range(nx - 1):&#10;        for j in range(ny - 1):&#10;            p1 = i * ny + j&#10;            p2 = i * ny + (j + 1)&#10;            p3 = (i + 1) * ny + (j + 1)&#10;            p4 = (i + 1) * ny + j&#10;            faces.extend([4, p1, p2, p3, p4])&#10;            p1b, p2b, p3b, p4b = p1 + offset, p2 + offset, p3 + offset, p4 + offset&#10;            faces.extend([4, p4b, p3b, p2b, p1b])&#10;&#10;    # lados&#10;    for i in range(nx - 1):&#10;        # izquierda (j=0)&#10;        p1t = i * ny + 0&#10;        p2t = (i + 1) * ny + 0&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p1b, p2b, p2t])&#10;        # derecha (j=ny-1)&#10;        p1t = i * ny + (ny - 1)&#10;        p2t = (i + 1) * ny + (ny - 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p2b, p1b, p1t])&#10;&#10;    for j in range(ny - 1):&#10;        # arriba (i=0)&#10;        p1t = 0 * ny + j&#10;        p2t = 0 * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p2t, p2b, p1b])&#10;        # abajo (i=nx-1)&#10;        p1t = (nx - 1) * ny + j&#10;        p2t = (nx - 1) * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p1t, p1b, p2b])&#10;&#10;    p(70, &quot;Optimizando mesh...&quot;)&#10;    points_array = np.array(points, dtype=np.float32)&#10;    # convertir quads a triángulos para pyvista&#10;    triangles = []&#10;    for k in range(0, len(faces), 5):&#10;        if k + 4 &lt; len(faces):&#10;            _, a, b, c, d = faces[k:k+5]&#10;            triangles.extend([3, a, b, c])&#10;            triangles.extend([3, a, c, d])&#10;    mesh = pv.PolyData(points_array, np.array(triangles))&#10;    mesh = mesh.clean(tolerance=1e-3)&#10;&#10;    p(90, &quot;Guardando STL...&quot;)&#10;    Path(out_dir).mkdir(parents=True, exist_ok=True)&#10;    mesh.save(out_path)&#10;&#10;    p(100, &quot;Completado&quot;)&#10;    return out_path&#10;&#10;def generate_full_ecuador_map(out_dir: Optional[str] = None, progress_callback: ProgressCB = None,&#10;                        resolution: str = &quot;medium&quot;, only_ecuador: bool = True) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Genera un modelo 3D combinado de todo el territorio usando los archivos HGT disponibles.&#10;    Optimizado para manejar conjuntos grandes de datos en todas las calidades.&#10;    &quot;&quot;&quot;&#10;    def p(val, msg):&#10;        if progress_callback:&#10;            progress_callback(val, msg)&#10;&#10;    # Aseguramos que existan las carpetas necesarias&#10;    Paths.ensure()&#10;    if out_dir is None:&#10;        out_dir = str(Paths.stl_dir)&#10;&#10;    # Parámetros ajustados para manejar mejor los mapas completos (todos los HGT)&#10;    if only_ecuador:&#10;        # Para Ecuador, podemos usar parámetros más altos&#10;        if resolution == &quot;low&quot;:&#10;            skip = 16&#10;            smoothing = 2.0&#10;            max_pixels = 1500000&#10;            vertical_exaggeration = 0.15&#10;            max_faces = 400000&#10;        elif resolution == &quot;high&quot;:&#10;            skip = 6&#10;            smoothing = 0.8&#10;            max_pixels = 4000000&#10;            vertical_exaggeration = 0.20&#10;            max_faces = 1200000&#10;        else:  # medium&#10;            skip = 10&#10;            smoothing = 1.2&#10;            max_pixels = 2500000&#10;            vertical_exaggeration = 0.18&#10;            max_faces = 800000&#10;    else:&#10;        # Para todos los HGT, usamos parámetros más conservadores&#10;        if resolution == &quot;low&quot;:&#10;            skip = 20  # Más conservador para todos los archivos&#10;            smoothing = 2.5&#10;            max_pixels = 1000000  # Límite más bajo&#10;            vertical_exaggeration = 0.12&#10;            max_faces = 300000&#10;        elif resolution == &quot;high&quot;:&#10;            skip = 12  # Más conservador que Ecuador solo&#10;            smoothing = 1.5&#10;            max_pixels = 2000000  # Límite más bajo que Ecuador&#10;            vertical_exaggeration = 0.16&#10;            max_faces = 600000&#10;        else:  # medium&#10;            skip = 16  # Más conservador&#10;            smoothing = 2.0&#10;            max_pixels = 1500000&#10;            vertical_exaggeration = 0.14&#10;            max_faces = 450000&#10;&#10;    # Nombre de archivo para el mapa completo&#10;    area_text = &quot;ecuador&quot; if only_ecuador else &quot;completo&quot;&#10;    out_path = str(Path(out_dir) / f&quot;mapa_{area_text}_{resolution}.stl&quot;)&#10;&#10;    # 1. Encontrar todos los archivos HGT&#10;    p(5, f&quot;Buscando archivos HGT{' de Ecuador' if only_ecuador else ''}...&quot;)&#10;    hgt_files = find_hgt_files(only_ecuador=only_ecuador)&#10;    if not hgt_files:&#10;        raise ValueError(f&quot;No se encontraron archivos HGT{' para Ecuador' if only_ecuador else ''}&quot;)&#10;&#10;    # Limitar número de archivos más agresivamente para mapas completos&#10;    max_files = 50 if only_ecuador else 30  # Límite más bajo para todos los HGT&#10;    if len(hgt_files) &gt; max_files:&#10;        p(8, f&quot;Limitando archivos HGT de {len(hgt_files)} a {max_files} para estabilidad&quot;)&#10;        hgt_files = hgt_files[:max_files]&#10;&#10;    p(10, f&quot;Se procesarán {len(hgt_files)} archivos HGT&quot;)&#10;&#10;    # 2. Determinar las dimensiones del mapa completo&#10;    min_lat = min(f[&quot;lat&quot;] for f in hgt_files)&#10;    max_lat = max(f[&quot;lat&quot;] + 1 for f in hgt_files)&#10;    min_lon = min(f[&quot;lon&quot;] for f in hgt_files)&#10;    max_lon = max(f[&quot;lon&quot;] + 1 for f in hgt_files)&#10;&#10;    lat_range = max_lat - min_lat&#10;    lon_range = max_lon - min_lon&#10;&#10;    p(15, f&quot;Área: {lon_range:.1f}° x {lat_range:.1f}°&quot;)&#10;&#10;    # 3. Crear un grid combinado con límites adaptativos&#10;    points_per_degree = 1201 // skip&#10;&#10;    # Calcular dimensiones y aplicar límites más estrictos para mapas completos&#10;    width = int(lon_range * points_per_degree)&#10;    height = int(lat_range * points_per_degree)&#10;&#10;    pixels = width * height&#10;    if pixels &gt; max_pixels:&#10;        factor = (pixels / max_pixels) ** 0.5&#10;        skip = int(skip * factor)&#10;        points_per_degree = 1201 // skip&#10;        width = int(lon_range * points_per_degree)&#10;        height = int(lat_range * points_per_degree)&#10;        p(20, f&quot;Ajustando resolución: skip={skip}, grid={width}x{height}&quot;)&#10;&#10;    p(20, f&quot;Creando grid optimizado ({width}x{height} = {width*height:,} puntos)...&quot;)&#10;    combined_dem = np.full((height, width), np.nan, dtype=np.float32)&#10;&#10;    # 4. Procesar archivos HGT con gestión de memoria más agresiva&#10;    total_files = len(hgt_files)&#10;    # Lotes más pequeños para mapas completos&#10;    batch_size = 2 if not only_ecuador and resolution == &quot;high&quot; else 3 if not only_ecuador else 5&#10;&#10;    for batch_start in range(0, total_files, batch_size):&#10;        batch_end = min(batch_start + batch_size, total_files)&#10;        batch_files = hgt_files[batch_start:batch_end]&#10;&#10;        for i, hgt_file in enumerate(batch_files):&#10;            file_idx = batch_start + i&#10;            prog_val = 20 + int((file_idx / total_files) * 35)&#10;            p(prog_val, f&quot;Procesando {hgt_file['name']} ({file_idx+1}/{total_files})...&quot;)&#10;&#10;            try:&#10;                # Cargar archivo HGT&#10;                dem = read_hgt_array(hgt_file[&quot;path&quot;])&#10;&#10;                # Submuestreo inteligente adaptativo&#10;                if skip &gt; 1:&#10;                    # Para mapas completos, usar submuestreo más simple para ahorrar memoria&#10;                    if only_ecuador and skip &lt;= 10:&#10;                        # Solo usar filtro de máximos para Ecuador con alta resolución&#10;                        from scipy.ndimage import maximum_filter&#10;                        kernel_size = min(skip, 3)&#10;                        dem_filtered = maximum_filter(dem, size=kernel_size)&#10;                        dem = dem_filtered[::skip, ::skip].astype(np.float32)&#10;                    else:&#10;                        # Submuestreo simple para casos de mucha memoria&#10;                        dem = dem[::skip, ::skip].astype(np.float32)&#10;                else:&#10;                    dem = dem.astype(np.float32)&#10;&#10;                # Calcular posición en el grid&#10;                x_offset = int((hgt_file[&quot;lon&quot;] - min_lon) * points_per_degree)&#10;                y_offset = int((max_lat - hgt_file[&quot;lat&quot;] - 1) * points_per_degree)&#10;&#10;                # Verificar límites y insertar&#10;                if (0 &lt;= x_offset &lt; width and 0 &lt;= y_offset &lt; height and&#10;                    x_offset + dem.shape[1] &lt;= width and y_offset + dem.shape[0] &lt;= height):&#10;                    combined_dem[y_offset:y_offset+dem.shape[0], x_offset:x_offset+dem.shape[1]] = dem&#10;&#10;                # Liberar memoria más frecuentemente&#10;                del dem&#10;&#10;            except Exception as e:&#10;                p(prog_val, f&quot;Error en {hgt_file['name']}: {e}&quot;)&#10;&#10;        # Liberación de memoria más agresiva&#10;        import gc&#10;        gc.collect()&#10;&#10;    # 5. Procesamiento de datos preservando características del terreno&#10;    p(60, &quot;Rellenando huecos preservando características...&quot;)&#10;&#10;    mask = np.isnan(combined_dem)&#10;    if np.any(mask):&#10;        # Método más sofisticado para rellenar que preserve el relieve&#10;        from scipy.ndimage import distance_transform_edt, binary_dilation&#10;&#10;        valid_data = combined_dem[~mask]&#10;        if len(valid_data) &gt; 0:&#10;            # Usar interpolación por distancia para preservar gradientes&#10;            distances, indices = distance_transform_edt(mask, return_indices=True)&#10;            combined_dem[mask] = combined_dem[tuple(indices[:, mask])]&#10;&#10;        del valid_data, mask&#10;&#10;    # Suavizado selectivo que preserve bordes (montañas)&#10;    p(70, &quot;Aplicando suavizado inteligente...&quot;)&#10;    if smoothing &gt; 0:&#10;        # Usar filtro gaussiano con truncado más bajo para preservar detalles&#10;        combined_dem = gaussian_filter(combined_dem, sigma=smoothing, truncate=1.5)&#10;&#10;    # 6. Escalado vertical mejorado para resaltar relieve&#10;    p(75, &quot;Optimizando relieve para impresión 3D...&quot;)&#10;&#10;    z_min = np.min(combined_dem)&#10;    z_max = np.max(combined_dem)&#10;    z_range = z_max - z_min&#10;&#10;    # Usar exageración vertical variable según la resolución&#10;    horizontal_size = max(width, height)&#10;    target_height_ratio = vertical_exaggeration&#10;    vertical_scale = (horizontal_size * target_height_ratio) / z_range if z_range &gt; 0 else 1&#10;&#10;    # Aplicar compresión no lineal para resaltar montañas&#10;    combined_dem_normalized = (combined_dem - z_min) / z_range if z_range &gt; 0 else combined_dem - z_min&#10;&#10;    # Función de mapeo que resalta las elevaciones altas (cordillera)&#10;    gamma = 0.7  # Valor &lt; 1 resalta las elevaciones altas&#10;    combined_dem_enhanced = np.power(combined_dem_normalized, gamma)&#10;&#10;    combined_dem = z_min + (combined_dem_enhanced * z_range * vertical_scale)&#10;&#10;    # 7. Crear malla 3D preservando detalle&#10;    p(80, &quot;Creando modelo 3D de alta definición...&quot;)&#10;&#10;    # Decimación más conservadora para preservar detalle&#10;    decimation_factor = 1  # No decimar por defecto&#10;    if width * height &gt; max_pixels * 1.5:  # Solo decimar si es absolutamente necesario&#10;        decimation_factor = 2&#10;        combined_dem = combined_dem[::decimation_factor, ::decimation_factor]&#10;        width = combined_dem.shape[1]&#10;        height = combined_dem.shape[0]&#10;        p(82, f&quot;Grid ajustado a {width}x{height} para mantener detalle&quot;)&#10;&#10;    # Crear coordenadas con escala apropiada&#10;    y_coords, x_coords = np.mgrid[0:height, 0:width]&#10;&#10;    # Escalar para impresión manteniendo proporciones&#10;    max_print_size = 150 if resolution == &quot;high&quot; else 130 if resolution == &quot;medium&quot; else 110&#10;    scale_factor = max_print_size / max(width, height)&#10;&#10;    x_coords = x_coords.astype(np.float32) * scale_factor&#10;    y_coords = y_coords.astype(np.float32) * scale_factor&#10;    combined_dem = combined_dem.astype(np.float32) * scale_factor&#10;&#10;    # 8. Crear malla con PyVista usando métodos compatibles&#10;    p(85, &quot;Ensamblando modelo final...&quot;)&#10;&#10;    try:&#10;        # Crear grid estructurado&#10;        grid = pv.StructuredGrid(x_coords, y_coords, combined_dem)&#10;&#10;        # Liberar arrays grandes inmediatamente&#10;        del x_coords, y_coords, combined_dem&#10;        import gc&#10;        gc.collect()&#10;&#10;        # Extraer superficie&#10;        surface = grid.extract_surface()&#10;        del grid&#10;        gc.collect()&#10;&#10;        # Usar método compatible para obtener número de caras&#10;        def get_n_faces(mesh):&#10;            if hasattr(mesh, 'n_cells'):&#10;                return mesh.n_cells&#10;            elif hasattr(mesh, 'GetNumberOfCells'):&#10;                return mesh.GetNumberOfCells()&#10;            else:&#10;                # Fallback para versiones muy antiguas&#10;                return len(mesh.faces) // 4 if hasattr(mesh, 'faces') else 0&#10;&#10;        # Simplificación más conservadora para preservar detalle geográfico&#10;        n_faces = get_n_faces(surface)&#10;        if n_faces &gt; max_faces:&#10;            reduction_factor = max_faces / n_faces&#10;            p(87, f&quot;Optimizando modelo ({n_faces:,} -&gt; {max_faces:,} caras)...&quot;)&#10;            surface = surface.decimate(1 - reduction_factor)&#10;&#10;        # 9. Base optimizada&#10;        p(90, &quot;Añadiendo base estructural...&quot;)&#10;&#10;        base_thickness = 3 if resolution == &quot;high&quot; else 2.5 if resolution == &quot;medium&quot; else 2&#10;        z_min = float(np.min(surface.points[:, 2]))&#10;        base_height = z_min - base_thickness&#10;&#10;        bounds = surface.bounds&#10;        base = pv.Box([bounds[0], bounds[1], bounds[2], bounds[3], base_height, base_height])&#10;&#10;        # Combinar componentes usando método compatible&#10;        p(92, &quot;Integrando componentes...&quot;)&#10;        try:&#10;            # Intentar método moderno primero&#10;            model = surface.copy()&#10;            if hasattr(model, 'append_polydata'):&#10;                model = model.append_polydata(base)&#10;            else:&#10;                # Fallback para versiones anteriores&#10;                model = surface + base&#10;        except:&#10;            # Último fallback&#10;            model = surface + base&#10;&#10;        del surface, base&#10;        gc.collect()&#10;&#10;        # Limpieza final más conservadora&#10;        p(95, &quot;Refinamiento final...&quot;)&#10;        model = model.clean(tolerance=0.001)  # Tolerancia más alta para estabilidad&#10;&#10;        # Verificación final con método compatible&#10;        n_faces_final = get_n_faces(model)&#10;        if n_faces_final &gt; max_faces * 1.2:&#10;            p(97, f&quot;Simplificación final conservadora...&quot;)&#10;            target_reduction = 1 - (max_faces / n_faces_final)&#10;            model = model.decimate(target_reduction * 0.8)&#10;&#10;        # 10. Guardar modelo optimizado&#10;        n_points = model.n_points if hasattr(model, 'n_points') else len(model.points)&#10;        n_faces_save = get_n_faces(model)&#10;        p(98, f&quot;Guardando modelo ({n_points:,} puntos, {n_faces_save:,} caras)...&quot;)&#10;        Path(out_dir).mkdir(parents=True, exist_ok=True)&#10;&#10;        model.save(out_path, binary=True)&#10;&#10;        del model&#10;        gc.collect()&#10;&#10;        area_desc = &quot;Ecuador&quot; if only_ecuador else &quot;todas las regiones&quot;&#10;        p(100, f&quot;¡Mapa de {area_desc} generado correctamente!&quot;)&#10;        return out_path&#10;&#10;    except Exception as e:&#10;        import gc&#10;        gc.collect()&#10;        raise RuntimeError(f&quot;Error al crear modelo 3D: {str(e)}&quot;)&#10;" />
              <option name="updatedContent" value="from typing import Callable, Optional&#10;from pathlib import Path&#10;import numpy as np&#10;from scipy.ndimage import gaussian_filter&#10;import pyvista as pv&#10;from core.paths import Paths&#10;from core.hgt_utils import read_hgt_array, find_hgt_files&#10;&#10;ProgressCB = Optional[Callable[[int, str], None]]&#10;&#10;def generate_stl_from_hgt(hgt_path: str, out_dir: Optional[str] = None, progress: ProgressCB = None) -&gt; str:&#10;    def p(val, msg):&#10;        if progress: progress(val, msg)&#10;&#10;    Paths.ensure()&#10;    if out_dir is None:&#10;        out_dir = str(Paths.stl_dir)&#10;&#10;    name = Path(hgt_path).stem&#10;    out_path = str(Path(out_dir) / f&quot;{name}_solido.stl&quot;)&#10;&#10;    p(5, &quot;Leyendo HGT...&quot;)&#10;    Z = read_hgt_array(hgt_path)&#10;&#10;    p(20, &quot;Suavizando elevación...&quot;)&#10;    Z = gaussian_filter(Z, sigma=5.0, truncate=2.5)&#10;&#10;    p(30, &quot;Submuestreando...&quot;)&#10;    skip = 6&#10;    Z = Z[::skip, ::skip]&#10;    nx, ny = Z.shape&#10;    x = np.linspace(0, nx - 1, nx)&#10;    y = np.linspace(0, ny - 1, ny)&#10;    X, Y = np.meshgrid(x, y, indexing=&quot;ij&quot;)&#10;&#10;    p(40, &quot;Construyendo base y bordes...&quot;)&#10;    # Escalado vertical y normalización (similar a tu lógica)&#10;    Z_scaled = Z * 0.12&#10;    zmin, zmax = float(np.min(Z_scaled)), float(np.max(Z_scaled))&#10;    rng = zmax - zmin if zmax &gt; zmin else 1.0&#10;    Z_norm = (Z_scaled - zmin) / rng&#10;    compression_factor = 0.6&#10;    Z_comp = np.where(Z_norm &gt; 0.3, 0.3 + (Z_norm - 0.3)*compression_factor, Z_norm)&#10;    Z_scaled = zmin + Z_comp * rng&#10;&#10;    zmin = float(np.min(Z_scaled))&#10;    base_thickness = 20.0&#10;    base_height = zmin - base_thickness&#10;&#10;    # Borde suave hacia la base&#10;    edge_fade = 10&#10;    Z_smooth = Z_scaled.copy()&#10;    for i in range(edge_fade):&#10;        alpha = i / edge_fade&#10;        Z_smooth[i, :]       = np.minimum(Z_smooth[i, :],       base_height + (Z_smooth[i, :]       - base_height) * alpha)&#10;        Z_smooth[-(i+1), :]  = np.minimum(Z_smooth[-(i+1), :],  base_height + (Z_smooth[-(i+1), :]  - base_height) * alpha)&#10;        Z_smooth[:, i]       = np.minimum(Z_smooth[:, i],       base_height + (Z_smooth[:, i]       - base_height) * alpha)&#10;        Z_smooth[:, -(i+1)]  = np.minimum(Z_smooth[:, -(i+1)],  base_height + (Z_smooth[:, -(i+1)]  - base_height) * alpha)&#10;&#10;    p(55, &quot;Construyendo malla sólida...&quot;)&#10;    points = []&#10;    # superficie&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], Z_smooth[i, j]])&#10;    # base&#10;    for i in range(nx):&#10;        for j in range(ny):&#10;            points.append([X[i, j], Y[i, j], base_height])&#10;&#10;    offset = nx * ny&#10;    faces = []&#10;    # top y base&#10;    for i in range(nx - 1):&#10;        for j in range(ny - 1):&#10;            p1 = i * ny + j&#10;            p2 = i * ny + (j + 1)&#10;            p3 = (i + 1) * ny + (j + 1)&#10;            p4 = (i + 1) * ny + j&#10;            faces.extend([4, p1, p2, p3, p4])&#10;            p1b, p2b, p3b, p4b = p1 + offset, p2 + offset, p3 + offset, p4 + offset&#10;            faces.extend([4, p4b, p3b, p2b, p1b])&#10;&#10;    # lados&#10;    for i in range(nx - 1):&#10;        # izquierda (j=0)&#10;        p1t = i * ny + 0&#10;        p2t = (i + 1) * ny + 0&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p1b, p2b, p2t])&#10;        # derecha (j=ny-1)&#10;        p1t = i * ny + (ny - 1)&#10;        p2t = (i + 1) * ny + (ny - 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p2b, p1b, p1t])&#10;&#10;    for j in range(ny - 1):&#10;        # arriba (i=0)&#10;        p1t = 0 * ny + j&#10;        p2t = 0 * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p1t, p2t, p2b, p1b])&#10;        # abajo (i=nx-1)&#10;        p1t = (nx - 1) * ny + j&#10;        p2t = (nx - 1) * ny + (j + 1)&#10;        p1b = p1t + offset&#10;        p2b = p2t + offset&#10;        faces.extend([4, p2t, p1t, p1b, p2b])&#10;&#10;    p(70, &quot;Optimizando mesh...&quot;)&#10;    points_array = np.array(points, dtype=np.float32)&#10;    # convertir quads a triángulos para pyvista&#10;    triangles = []&#10;    for k in range(0, len(faces), 5):&#10;        if k + 4 &lt; len(faces):&#10;            _, a, b, c, d = faces[k:k+5]&#10;            triangles.extend([3, a, b, c])&#10;            triangles.extend([3, a, c, d])&#10;    mesh = pv.PolyData(points_array, np.array(triangles))&#10;    mesh = mesh.clean(tolerance=1e-3)&#10;&#10;    p(90, &quot;Guardando STL...&quot;)&#10;    Path(out_dir).mkdir(parents=True, exist_ok=True)&#10;    mesh.save(out_path)&#10;&#10;    p(100, &quot;Completado&quot;)&#10;    return out_path&#10;&#10;def generate_full_ecuador_map(out_dir: Optional[str] = None, progress_callback: ProgressCB = None, &#10;                        resolution: str = &quot;medium&quot;, only_ecuador: bool = True) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Genera un modelo 3D SÓLIDO (no hueco) de todo el territorio usando los archivos HGT disponibles.&#10;    Optimizado para usar más recursos de hardware y mantener alta calidad.&#10;    &quot;&quot;&quot;&#10;    def p(val, msg):&#10;        if progress_callback: &#10;            progress_callback(val, msg)&#10;&#10;    # Aseguramos que existan las carpetas necesarias&#10;    Paths.ensure()&#10;    if out_dir is None:&#10;        out_dir = str(Paths.stl_dir)&#10;&#10;    # Parámetros agresivos para aprovechar mejor el hardware disponible&#10;    # Usando 70% CPU y 80% RAM disponible&#10;    if only_ecuador:&#10;        # Para Ecuador, usar parámetros muy altos aprovechando los recursos&#10;        if resolution == &quot;low&quot;:&#10;            skip = 12  # Mejor calidad (era 16)&#10;            smoothing = 1.5  # Menos suavizado&#10;            max_pixels = 3000000  # Mucho más alto (era 1.5M)&#10;            vertical_exaggeration = 0.18&#10;            max_faces = 800000  # Más caras&#10;        elif resolution == &quot;high&quot;:&#10;            skip = 4  # Máxima calidad (era 6)&#10;            smoothing = 0.6  # Mínimo suavizado&#10;            max_pixels = 8000000  # Máximo aprovechamiento RAM (era 4M)&#10;            vertical_exaggeration = 0.25&#10;            max_faces = 2000000  # Mucho más detalle&#10;        else:  # medium&#10;            skip = 7  # Mejor calidad (era 10)&#10;            smoothing = 1.0  # Menos suavizado&#10;            max_pixels = 5000000  # Aprovechar RAM (era 2.5M)&#10;            vertical_exaggeration = 0.22&#10;            max_faces = 1500000  # Más caras&#10;    else:&#10;        # Para todos los HGT, usar parámetros más altos aprovechando recursos&#10;        if resolution == &quot;low&quot;:&#10;            skip = 16  # Mejor que antes (era 20)&#10;            smoothing = 2.0  # Menos suavizado&#10;            max_pixels = 2000000  # Más píxeles (era 1M)&#10;            vertical_exaggeration = 0.15&#10;            max_faces = 600000  # Más caras&#10;        elif resolution == &quot;high&quot;:&#10;            skip = 8  # Mucho mejor (era 12)&#10;            smoothing = 1.0  # Menos suavizado&#10;            max_pixels = 4000000  # Aprovechar RAM (era 2M)&#10;            vertical_exaggeration = 0.20&#10;            max_faces = 1200000  # Más detalle&#10;        else:  # medium&#10;            skip = 12  # Mejor calidad (era 16)&#10;            smoothing = 1.5  # Menos suavizado&#10;            max_pixels = 3000000  # Más píxeles (era 1.5M)&#10;            vertical_exaggeration = 0.18&#10;            max_faces = 900000  # Más caras&#10;&#10;    # Nombre de archivo para el mapa completo&#10;    area_text = &quot;ecuador&quot; if only_ecuador else &quot;completo&quot;&#10;    out_path = str(Path(out_dir) / f&quot;mapa_solido_{area_text}_{resolution}.stl&quot;)&#10;&#10;    # 1. Encontrar todos los archivos HGT&#10;    p(5, f&quot;Buscando archivos HGT{' de Ecuador' if only_ecuador else ''}...&quot;)&#10;    hgt_files = find_hgt_files(only_ecuador=only_ecuador)&#10;    if not hgt_files:&#10;        raise ValueError(f&quot;No se encontraron archivos HGT{' para Ecuador' if only_ecuador else ''}&quot;)&#10;&#10;    # Aprovechar mejor los recursos - procesar más archivos&#10;    max_files = 80 if only_ecuador else 50  # Más archivos para mejor cobertura&#10;    if len(hgt_files) &gt; max_files:&#10;        p(8, f&quot;Procesando {max_files} de {len(hgt_files)} archivos HGT para optimizar recursos&quot;)&#10;        hgt_files = hgt_files[:max_files]&#10;&#10;    p(10, f&quot;Se procesarán {len(hgt_files)} archivos HGT para modelo SÓLIDO&quot;)&#10;&#10;    # 2. Determinar las dimensiones del mapa completo&#10;    min_lat = min(f[&quot;lat&quot;] for f in hgt_files)&#10;    max_lat = max(f[&quot;lat&quot;] + 1 for f in hgt_files)&#10;    min_lon = min(f[&quot;lon&quot;] for f in hgt_files)&#10;    max_lon = max(f[&quot;lon&quot;] + 1 for f in hgt_files)&#10;&#10;    lat_range = max_lat - min_lat&#10;    lon_range = max_lon - min_lon&#10;&#10;    p(15, f&quot;Área: {lon_range:.1f}° x {lat_range:.1f}°&quot;)&#10;&#10;    # 3. Crear un grid de alta resolución aprovechando la RAM disponible&#10;    points_per_degree = 1201 // skip&#10;&#10;    width = int(lon_range * points_per_degree)&#10;    height = int(lat_range * points_per_degree)&#10;&#10;    pixels = width * height&#10;    if pixels &gt; max_pixels:&#10;        factor = (pixels / max_pixels) ** 0.5&#10;        skip = int(skip * factor)&#10;        points_per_degree = 1201 // skip&#10;        width = int(lon_range * points_per_degree)&#10;        height = int(lat_range * points_per_degree)&#10;        p(20, f&quot;Ajustando para modelo sólido: skip={skip}, grid={width}x{height}&quot;)&#10;    &#10;    p(20, f&quot;Creando grid de alta resolución para modelo SÓLIDO ({width}x{height} = {width*height:,} puntos)...&quot;)&#10;    combined_dem = np.full((height, width), np.nan, dtype=np.float32)&#10;&#10;    # 4. Procesamiento paralelo aprovechando los núcleos disponibles&#10;    total_files = len(hgt_files)&#10;    # Lotes más grandes para aprovechar el CPU&#10;    batch_size = 8 if only_ecuador else 6  # Más archivos por lote&#10;    &#10;    for batch_start in range(0, total_files, batch_size):&#10;        batch_end = min(batch_start + batch_size, total_files)&#10;        batch_files = hgt_files[batch_start:batch_end]&#10;&#10;        for i, hgt_file in enumerate(batch_files):&#10;            file_idx = batch_start + i&#10;            prog_val = 20 + int((file_idx / total_files) * 35)&#10;            p(prog_val, f&quot;Procesando {hgt_file['name']} ({file_idx+1}/{total_files})...&quot;)&#10;&#10;            try:&#10;                # Cargar archivo HGT&#10;                dem = read_hgt_array(hgt_file[&quot;path&quot;])&#10;&#10;                # Submuestreo inteligente adaptativo&#10;                if skip &gt; 1:&#10;                    # Para mapas completos, usar submuestreo más simple para ahorrar memoria&#10;                    if only_ecuador and skip &lt;= 10:&#10;                        # Solo usar filtro de máximos para Ecuador con alta resolución&#10;                        from scipy.ndimage import maximum_filter&#10;                        kernel_size = min(skip, 3)&#10;                        dem_filtered = maximum_filter(dem, size=kernel_size)&#10;                        dem = dem_filtered[::skip, ::skip].astype(np.float32)&#10;                    else:&#10;                        # Submuestreo simple para casos de mucha memoria&#10;                        dem = dem[::skip, ::skip].astype(np.float32)&#10;                else:&#10;                    dem = dem.astype(np.float32)&#10;&#10;                # Calcular posición en el grid&#10;                x_offset = int((hgt_file[&quot;lon&quot;] - min_lon) * points_per_degree)&#10;                y_offset = int((max_lat - hgt_file[&quot;lat&quot;] - 1) * points_per_degree)&#10;&#10;                # Verificar límites y insertar&#10;                if (0 &lt;= x_offset &lt; width and 0 &lt;= y_offset &lt; height and&#10;                    x_offset + dem.shape[1] &lt;= width and y_offset + dem.shape[0] &lt;= height):&#10;                    combined_dem[y_offset:y_offset+dem.shape[0], x_offset:x_offset+dem.shape[1]] = dem&#10;&#10;                # Liberar memoria más frecuentemente&#10;                del dem&#10;&#10;            except Exception as e:&#10;                p(prog_val, f&quot;Error en {hgt_file['name']}: {e}&quot;)&#10;&#10;        # Liberación de memoria más agresiva&#10;        import gc&#10;        gc.collect()&#10;&#10;    # 5. Procesamiento de datos preservando características del terreno&#10;    p(60, &quot;Rellenando huecos preservando características...&quot;)&#10;&#10;    mask = np.isnan(combined_dem)&#10;    if np.any(mask):&#10;        # Método más sofisticado para rellenar que preserve el relieve&#10;        from scipy.ndimage import distance_transform_edt, binary_dilation&#10;&#10;        valid_data = combined_dem[~mask]&#10;        if len(valid_data) &gt; 0:&#10;            # Usar interpolación por distancia para preservar gradientes&#10;            distances, indices = distance_transform_edt(mask, return_indices=True)&#10;            combined_dem[mask] = combined_dem[tuple(indices[:, mask])]&#10;&#10;        del valid_data, mask&#10;&#10;    # Suavizado selectivo que preserve bordes (montañas)&#10;    p(70, &quot;Aplicando suavizado inteligente...&quot;)&#10;    if smoothing &gt; 0:&#10;        # Usar filtro gaussiano con truncado más bajo para preservar detalles&#10;        combined_dem = gaussian_filter(combined_dem, sigma=smoothing, truncate=1.5)&#10;&#10;    # 6. Escalado vertical mejorado para resaltar relieve&#10;    p(75, &quot;Optimizando relieve para impresión 3D...&quot;)&#10;&#10;    z_min = np.min(combined_dem)&#10;    z_max = np.max(combined_dem)&#10;    z_range = z_max - z_min&#10;&#10;    # Usar exageración vertical variable según la resolución&#10;    horizontal_size = max(width, height)&#10;    target_height_ratio = vertical_exaggeration&#10;    vertical_scale = (horizontal_size * target_height_ratio) / z_range if z_range &gt; 0 else 1&#10;&#10;    # Aplicar compresión no lineal para resaltar montañas&#10;    combined_dem_normalized = (combined_dem - z_min) / z_range if z_range &gt; 0 else combined_dem - z_min&#10;&#10;    # Función de mapeo que resalta las elevaciones altas (cordillera)&#10;    gamma = 0.7  # Valor &lt; 1 resalta las elevaciones altas&#10;    combined_dem_enhanced = np.power(combined_dem_normalized, gamma)&#10;&#10;    combined_dem = z_min + (combined_dem_enhanced * z_range * vertical_scale)&#10;&#10;    # 7. Crear malla 3D preservando detalle&#10;    p(80, &quot;Creando modelo 3D de alta definición...&quot;)&#10;&#10;    # Decimación más conservadora para preservar detalle geográfico&#10;    decimation_factor = 1  # No decimar por defecto&#10;    if width * height &gt; max_pixels * 1.5:  # Solo decimar si es absolutamente necesario&#10;        decimation_factor = 2&#10;        combined_dem = combined_dem[::decimation_factor, ::decimation_factor]&#10;        width = combined_dem.shape[1]&#10;        height = combined_dem.shape[0]&#10;        p(82, f&quot;Grid ajustado a {width}x{height} para mantener detalle&quot;)&#10;&#10;    # Crear coordenadas con escala apropiada&#10;    y_coords, x_coords = np.mgrid[0:height, 0:width]&#10;&#10;    # Escalar para impresión manteniendo proporciones&#10;    max_print_size = 150 if resolution == &quot;high&quot; else 130 if resolution == &quot;medium&quot; else 110&#10;    scale_factor = max_print_size / max(width, height)&#10;&#10;    x_coords = x_coords.astype(np.float32) * scale_factor&#10;    y_coords = y_coords.astype(np.float32) * scale_factor&#10;    combined_dem = combined_dem.astype(np.float32) * scale_factor&#10;&#10;    # 8. Crear malla SÓLIDA con PyVista usando métodos compatibles&#10;    p(80, &quot;Creando modelo 3D SÓLIDO de alta resolución...&quot;)&#10;    &#10;    try:&#10;        # Crear grid estructurado&#10;        grid = pv.StructuredGrid(x_coords, y_coords, combined_dem)&#10;        &#10;        # Liberar arrays grandes inmediatamente&#10;        del x_coords, y_coords, combined_dem&#10;        import gc&#10;        gc.collect()&#10;        &#10;        # Extraer superficie&#10;        surface = grid.extract_surface()&#10;        del grid&#10;        gc.collect()&#10;&#10;        # Usar método compatible para obtener número de caras&#10;        def get_n_faces(mesh):&#10;            try:&#10;                if hasattr(mesh, 'n_cells'):&#10;                    return mesh.n_cells&#10;                elif hasattr(mesh, 'GetNumberOfCells'):&#10;                    return mesh.GetNumberOfCells()&#10;                else:&#10;                    # Calcular manualmente si es necesario&#10;                    if hasattr(mesh, 'faces') and len(mesh.faces) &gt; 0:&#10;                        return len(mesh.faces) // 4  # Asumiendo quads&#10;                    return 0&#10;            except:&#10;                return 0&#10;        &#10;        # Simplificación conservadora para mantener calidad&#10;        n_faces = get_n_faces(surface)&#10;        if n_faces &gt; max_faces:&#10;            reduction_factor = max_faces / n_faces&#10;            p(85, f&quot;Optimizando modelo SÓLIDO ({n_faces:,} -&gt; {max_faces:,} caras)...&quot;)&#10;            surface = surface.decimate(1 - reduction_factor)&#10;        &#10;        # 9. Crear modelo completamente SÓLIDO&#10;        p(88, &quot;Generando modelo completamente SÓLIDO...&quot;)&#10;        &#10;        # Calcular base gruesa para modelo sólido&#10;        base_thickness = 5 if resolution == &quot;high&quot; else 4 if resolution == &quot;medium&quot; else 3&#10;        z_min = float(np.min(surface.points[:, 2]))&#10;        base_height = z_min - base_thickness&#10;        &#10;        # Crear base sólida&#10;        bounds = surface.bounds&#10;        base = pv.Box([bounds[0], bounds[1], bounds[2], bounds[3], base_height, base_height])&#10;        &#10;        # Crear paredes laterales para modelo sólido&#10;        p(90, &quot;Añadiendo paredes laterales para modelo sólido...&quot;)&#10;        &#10;        # Extruir los bordes hacia abajo para crear paredes sólidas&#10;        try:&#10;            # Extraer bordes de la superficie&#10;            edges = surface.extract_feature_edges(boundary_edges=True, feature_edges=False, manifold_edges=False)&#10;            &#10;            # Crear paredes extruyendo hacia abajo&#10;            if edges.n_points &gt; 0:&#10;                # Vector de extrusión hacia abajo&#10;                extrude_vector = [0, 0, base_height - z_min]&#10;                walls = edges.extrude(extrude_vector, capping=False)&#10;            else:&#10;                # Si no hay bordes, crear paredes manualmente&#10;                walls = pv.PolyData()  # Paredes vacías&#10;                &#10;        except Exception as e:&#10;            p(90, f&quot;Creando paredes alternativas: {e}&quot;)&#10;            # Método alternativo para crear paredes&#10;            walls = pv.PolyData()  # Paredes vacías si falla&#10;        &#10;        # Combinar todos los componentes para modelo sólido&#10;        p(92, &quot;Ensamblando modelo SÓLIDO final...&quot;)&#10;        &#10;        try:&#10;            # Método robusto para combinar componentes&#10;            components = [surface]&#10;            if walls.n_points &gt; 0:&#10;                components.append(walls)&#10;            components.append(base)&#10;            &#10;            # Usar el método más compatible&#10;            model = surface.copy()&#10;            for component in components[1:]:  # Saltar surface ya que es la base&#10;                try:&#10;                    if hasattr(model, 'append_polydata'):&#10;                        model = model.append_polydata(component)&#10;                    else:&#10;                        model = model + component&#10;                except:&#10;                    # Si falla, intentar método básico&#10;                    pass&#10;                    &#10;        except Exception as e:&#10;            p(92, f&quot;Usando método de combinación alternativo: {e}&quot;)&#10;            # Fallback: solo superficie + base&#10;            try:&#10;                if hasattr(surface, 'append_polydata'):&#10;                    model = surface.append_polydata(base)&#10;                else:&#10;                    model = surface + base&#10;            except:&#10;                model = surface  # Último recurso&#10;            &#10;        del surface, walls, base&#10;        gc.collect()&#10;        &#10;        # Verificar que el modelo sea sólido (watertight)&#10;        p(95, &quot;Verificando modelo sólido...&quot;)&#10;        &#10;        try:&#10;            # Intentar cerrar agujeros para asegurar que sea sólido&#10;            model = model.fill_holes(hole_size=model.length * 0.05)&#10;            &#10;            # Limpiar con tolerancia ajustada&#10;            model = model.clean(tolerance=0.0001)  # Tolerancia más baja para modelos sólidos&#10;            &#10;            # Verificar si es manifold (necesario para modelos sólidos)&#10;            if hasattr(model, 'is_manifold'):&#10;                if not model.is_manifold:&#10;                    p(96, &quot;Reparando geometría para modelo sólido...&quot;)&#10;                    model = model.smooth(n_iter=2, relaxation_factor=0.01)&#10;                    &#10;        except Exception as e:&#10;            p(95, f&quot;Aplicando limpieza básica: {e}&quot;)&#10;            model = model.clean(tolerance=0.001)&#10;        &#10;        # Verificación final de calidad&#10;        n_faces_final = get_n_faces(model)&#10;        if n_faces_final &gt; max_faces * 1.3:  # Permitir más caras para modelos sólidos&#10;            p(97, f&quot;Optimización final para modelo sólido...&quot;)&#10;            target_reduction = 1 - (max_faces / n_faces_final)&#10;            model = model.decimate(target_reduction * 0.9)  # Reducir menos agresivamente&#10;        &#10;        # 10. Guardar modelo sólido optimizado&#10;        n_points = model.n_points if hasattr(model, 'n_points') else len(model.points)&#10;        n_faces_save = get_n_faces(model)&#10;        p(98, f&quot;Guardando modelo SÓLIDO ({n_points:,} puntos, {n_faces_save:,} caras)...&quot;)&#10;        Path(out_dir).mkdir(parents=True, exist_ok=True)&#10;        &#10;        # Guardar como STL binario (más compacto para modelos sólidos)&#10;        model.save(out_path, binary=True)&#10;        &#10;        del model&#10;        gc.collect()&#10;        &#10;        area_desc = &quot;Ecuador&quot; if only_ecuador else &quot;todas las regiones&quot;&#10;        p(100, f&quot;¡Modelo SÓLIDO de {area_desc} generado correctamente!&quot;)&#10;        return out_path&#10;        &#10;    except Exception as e:&#10;        import gc&#10;        gc.collect()&#10;        raise RuntimeError(f&quot;Error al crear modelo 3D sólido: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import sys&#10;from PyQt6.QtWidgets import QApplication&#10;from app.ui.main_window import MainWindow&#10;&#10;def main():&#10;    app = QApplication(sys.argv)&#10;    win = MainWindow()&#10;    win.show()&#10;    sys.exit(app.exec())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
              <option name="updatedContent" value="import sys&#10;from PyQt6.QtWidgets import QApplication&#10;from ui.main_window import MainWindow&#10;&#10;def main():&#10;    app = QApplication(sys.argv)&#10;    win = MainWindow()&#10;    win.show()&#10;    sys.exit(app.exec())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value=" PyQt6&gt;=6.4.0&#10;numpy&gt;=1.24.0&#10;scipy&gt;=1.10.0&#10;matplotlib&gt;=3.7.0&#10;geopandas&gt;=0.12.0&#10;shapely&gt;=2.0.0&#10;pyvista&gt;=0.38.0&#10;pyvistaqt&gt;=0.9.0&#10;requests&gt;=2.28.0&#10;&#10;" />
              <option name="updatedContent" value="PyQt6&gt;=6.4.0&#10;numpy&gt;=1.24.0&#10;scipy&gt;=1.10.0&#10;matplotlib&gt;=3.7.0&#10;geopandas&gt;=0.12.0&#10;shapely&gt;=2.0.0&#10;pyvista&gt;=0.43.0,&lt;0.45.0&#10;pyvistaqt&gt;=0.9.0&#10;requests&gt;=2.28.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/main_window.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/main_window.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QPushButton, QFileDialog,&#10;                         QStackedWidget, QMessageBox, QLabel, QHBoxLayout, QDialog, QRadioButton, QGroupBox)&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtGui import QIcon, QPixmap&#10;from ui.map_selector_widget import MapSelectorWidget&#10;from ui.progress_dialog import ProgressDialog&#10;from ui.viewer_3d import Viewer3D&#10;from ui.workers import STLWorker&#10;from core.paths import Paths&#10;import os&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Mapa 3D Ecuador - Generador de STL&quot;)&#10;        self.resize(1200, 800)&#10;        Paths.ensure()&#10;&#10;        self.stack = QStackedWidget()&#10;        self.setCentralWidget(self.stack)&#10;&#10;        # Main menu&#10;        self.menu_page = QWidget()&#10;        self.create_main_menu()&#10;        self.stack.addWidget(self.menu_page)&#10;&#10;        # Map page&#10;        self.map_page = MapSelectorWidget(on_selected=self._on_tile_selected, on_back=self._go_menu)&#10;        self.stack.addWidget(self.map_page)&#10;&#10;        # Viewer page&#10;        self.viewer_page = Viewer3D(back_cb=self._go_menu)&#10;        self.stack.addWidget(self.viewer_page)&#10;&#10;        # Variables de estado&#10;        self.progress_dlg = None&#10;        self.worker = None&#10;&#10;        # Mostrar menú principal al inicio&#10;        self._go_menu()&#10;&#10;    def create_main_menu(self):&#10;        layout = QVBoxLayout(self.menu_page)&#10;&#10;        # Título&#10;        title_label = QLabel(&quot;Generador 3D de Terreno - Ecuador&quot;)&#10;        title_label.setStyleSheet(&quot;font-size: 24pt; font-weight: bold; color: #2c3e50; margin: 20px;&quot;)&#10;        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(title_label)&#10;&#10;        # Descripción&#10;        desc_label = QLabel(&quot;Seleccione una opción para comenzar:&quot;)&#10;        desc_label.setStyleSheet(&quot;font-size: 14pt; margin-bottom: 20px;&quot;)&#10;        desc_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(desc_label)&#10;&#10;        # Contenedor principal para los botones&#10;        btn_container = QWidget()&#10;        btn_layout = QVBoxLayout(btn_container)&#10;&#10;        # Estilo común para botones&#10;        button_style = &quot;&quot;&quot;&#10;        QPushButton {&#10;            font-size: 14pt;&#10;            padding: 12px;&#10;            margin: 10px 50px;&#10;            background-color: #3498db;&#10;            color: white;&#10;            border-radius: 8px;&#10;            min-width: 300px;&#10;        }&#10;        QPushButton:hover {&#10;            background-color: #2980b9;&#10;        }&#10;        &quot;&quot;&quot;&#10;&#10;        # Botones principales&#10;        self.btn_map = QPushButton(&quot;Seleccionar Zona en Mapa&quot;)&#10;        self.btn_map.setStyleSheet(button_style)&#10;&#10;        # Nuevo botón para generar todo el mapa&#10;        self.btn_full_map = QPushButton(&quot;Generar Todo el Mapa de Ecuador&quot;)&#10;        self.btn_full_map.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#27ae60&quot;).replace(&quot;#2980b9&quot;, &quot;#219955&quot;))&#10;&#10;        self.btn_open_stl = QPushButton(&quot;Abrir Modelo STL Existente&quot;)&#10;        self.btn_open_stl.setStyleSheet(button_style)&#10;        self.btn_settings = QPushButton(&quot;Configurar Carpetas de Datos&quot;)&#10;        self.btn_settings.setStyleSheet(button_style)&#10;        self.btn_exit = QPushButton(&quot;Salir&quot;)&#10;        self.btn_exit.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#e74c3c&quot;).replace(&quot;#2980b9&quot;, &quot;#c0392b&quot;))&#10;&#10;        btn_layout.addWidget(self.btn_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_full_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_open_stl, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_settings, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_exit, alignment=Qt.AlignmentFlag.AlignCenter)&#10;&#10;        layout.addWidget(btn_container)&#10;        layout.addStretch()&#10;&#10;        # Conexiones de botones&#10;        self.btn_map.clicked.connect(self._go_map)&#10;        self.btn_full_map.clicked.connect(self._generate_full_map)&#10;        self.btn_open_stl.clicked.connect(self._open_stl)&#10;        self.btn_settings.clicked.connect(self._settings)&#10;        self.btn_exit.clicked.connect(self.close)&#10;&#10;    def _go_menu(self):&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;    def _go_map(self):&#10;        self.map_page.load()&#10;        self.stack.setCurrentWidget(self.map_page)&#10;&#10;    def _open_stl(self):&#10;        fn, _ = QFileDialog.getOpenFileName(self, &quot;Abrir STL&quot;, str(Paths.stl_dir), &quot;STL (*.stl)&quot;)&#10;        if fn:&#10;            # Mostrar diálogo de carga mientras se abre el modelo&#10;            loading_dialog = ProgressDialog(&quot;Cargando modelo STL...&quot;)&#10;            loading_dialog.show()&#10;&#10;            def open_model():&#10;                loading_dialog.update_progress(50, f&quot;Cargando {os.path.basename(fn)}...&quot;)&#10;                self.viewer_page.load_stl(fn)&#10;                self.stack.setCurrentWidget(self.viewer_page)&#10;                loading_dialog.close()&#10;&#10;            # Usar QTimer para permitir que se muestre el diálogo antes de cargar&#10;            QTimer.singleShot(300, open_model)&#10;&#10;    def _settings(self):&#10;        # Configuración de carpetas&#10;        settings_dialog = QDialog(self)&#10;        settings_dialog.setWindowTitle(&quot;Configuración&quot;)&#10;        settings_dialog.setMinimumWidth(500)&#10;&#10;        layout = QVBoxLayout(settings_dialog)&#10;&#10;        # HGT Directory&#10;        hgt_layout = QHBoxLayout()&#10;        hgt_label = QLabel(&quot;Carpeta de archivos HGT:&quot;)&#10;        hgt_path = QLabel(str(Paths.hgt_dir))&#10;        hgt_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        hgt_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        hgt_layout.addWidget(hgt_label)&#10;        hgt_layout.addWidget(hgt_path, 1)  # 1 = stretch factor&#10;        hgt_layout.addWidget(hgt_btn)&#10;&#10;        # STL Directory&#10;        stl_layout = QHBoxLayout()&#10;        stl_label = QLabel(&quot;Carpeta de modelos STL:&quot;)&#10;        stl_path = QLabel(str(Paths.stl_dir))&#10;        stl_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        stl_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        stl_layout.addWidget(stl_label)&#10;        stl_layout.addWidget(stl_path, 1)  # 1 = stretch factor&#10;        stl_layout.addWidget(stl_btn)&#10;&#10;        # Close button&#10;        close_btn = QPushButton(&quot;Cerrar&quot;)&#10;        close_btn.clicked.connect(settings_dialog.accept)&#10;&#10;        layout.addLayout(hgt_layout)&#10;        layout.addLayout(stl_layout)&#10;        layout.addWidget(close_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;        # Connect buttons&#10;        def change_hgt():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de HGT&quot;, str(Paths.hgt_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_hgt_dir(new_dir)&#10;                self.map_page.hgt_root = str(Paths.hgt_dir)&#10;                hgt_path.setText(str(Paths.hgt_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta HGT configurada en:\n{Paths.hgt_dir}&quot;)&#10;&#10;        def change_stl():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de STL&quot;, str(Paths.stl_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_stl_dir(new_dir)&#10;                stl_path.setText(str(Paths.stl_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta STL configurada en:\n{Paths.stl_dir}&quot;)&#10;&#10;        hgt_btn.clicked.connect(change_hgt)&#10;        stl_btn.clicked.connect(change_stl)&#10;&#10;        settings_dialog.exec()&#10;&#10;    def _on_tile_selected(self, hgt_path: str):&#10;        # 1. Volver al menú principal y mostrar progreso&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;        # 2. Mostrar diálogo de progreso con estilo mejorado&#10;        self.progress_dlg = ProgressDialog(&quot;Generando modelo 3D...&quot;)&#10;        self.progress_dlg.setWindowTitle(f&quot;Generando modelo de {os.path.basename(hgt_path)}&quot;)&#10;        self.progress_dlg.show()&#10;&#10;        # 3. Iniciar worker en segundo plano&#10;        self.worker = STLWorker(hgt_path)&#10;        self.worker.progress.connect(self.progress_dlg.update_progress)&#10;        self.worker.finished.connect(self._on_generation_finished)&#10;        self.worker.start()&#10;&#10;    def _on_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Modelo generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;&#10;    def _generate_full_map(self):&#10;        # Crear un diálogo para seleccionar opciones&#10;        options_dialog = QDialog(self)&#10;        options_dialog.setWindowTitle(&quot;Opciones de Generación de Mapa&quot;)&#10;        options_dialog.setMinimumWidth(400)&#10;&#10;        layout = QVBoxLayout(options_dialog)&#10;&#10;        # Título&#10;        title = QLabel(&quot;Selecciona las opciones para generar el mapa:&quot;)&#10;        title.setStyleSheet(&quot;font-size: 14pt; font-weight: bold; margin-bottom: 15px;&quot;)&#10;        layout.addWidget(title)&#10;&#10;        # Opciones de área&#10;        area_group = QGroupBox(&quot;Área a generar:&quot;)&#10;        area_layout = QVBoxLayout()&#10;&#10;        ecuador_radio = QRadioButton(&quot;Solo Ecuador (más rápido)&quot;)&#10;        ecuador_radio.setChecked(True)&#10;        all_radio = QRadioButton(&quot;Todos los archivos HGT disponibles&quot;)&#10;&#10;        area_layout.addWidget(ecuador_radio)&#10;        area_layout.addWidget(all_radio)&#10;        area_group.setLayout(area_layout)&#10;&#10;        # Opciones de resolución&#10;        resolution_group = QGroupBox(&quot;Resolución:&quot;)&#10;        resolution_layout = QVBoxLayout()&#10;&#10;        low_radio = QRadioButton(&quot;Baja (más rápido, archivo pequeño)&quot;)&#10;        medium_radio = QRadioButton(&quot;Media (equilibrado)&quot;)&#10;        high_radio = QRadioButton(&quot;Alta (más detalle, archivo grande)&quot;)&#10;&#10;        medium_radio.setChecked(True)&#10;&#10;        resolution_layout.addWidget(low_radio)&#10;        resolution_layout.addWidget(medium_radio)&#10;        resolution_layout.addWidget(high_radio)&#10;        resolution_group.setLayout(resolution_layout)&#10;&#10;        # Botones&#10;        buttons = QHBoxLayout()&#10;        cancel_btn = QPushButton(&quot;Cancelar&quot;)&#10;        generate_btn = QPushButton(&quot;Generar&quot;)&#10;        generate_btn.setStyleSheet(&quot;background-color: #27ae60; color: white; font-weight: bold;&quot;)&#10;&#10;        buttons.addWidget(cancel_btn)&#10;        buttons.addWidget(generate_btn)&#10;&#10;        # Añadir todo al layout principal&#10;        layout.addWidget(area_group)&#10;        layout.addWidget(resolution_group)&#10;        layout.addLayout(buttons)&#10;&#10;        # Conexiones&#10;        cancel_btn.clicked.connect(options_dialog.reject)&#10;        generate_btn.clicked.connect(options_dialog.accept)&#10;&#10;        # Mostrar diálogo&#10;        if options_dialog.exec() == QDialog.DialogCode.Accepted:&#10;            # Obtener opciones seleccionadas&#10;            only_ecuador = ecuador_radio.isChecked()&#10;&#10;            if low_radio.isChecked():&#10;                resolution = &quot;low&quot;&#10;            elif high_radio.isChecked():&#10;                resolution = &quot;high&quot;&#10;            else:&#10;                resolution = &quot;medium&quot;&#10;&#10;            # 1. Volver al menú principal y mostrar progreso&#10;            self.stack.setCurrentWidget(self.menu_page)&#10;&#10;            # 2. Mostrar diálogo de progreso para la generación del mapa&#10;            area_text = &quot;Ecuador&quot; if only_ecuador else &quot;todos los archivos HGT&quot;&#10;            title_text = f&quot;Generando mapa 3D de {area_text}&quot;&#10;&#10;            self.progress_dlg = ProgressDialog(title_text)&#10;            self.progress_dlg.setWindowTitle(title_text)&#10;            self.progress_dlg.show()&#10;&#10;            # 3. Iniciar worker en segundo plano para la generación del mapa&#10;            self.worker = STLWorker(generate_full_map=True, only_ecuador=only_ecuador, resolution=resolution)&#10;            self.worker.progress.connect(self.progress_dlg.update_progress)&#10;            self.worker.finished.connect(self._on_full_map_generation_finished)&#10;            self.worker.start()&#10;        else:&#10;            # Cancelado&#10;            return&#10;&#10;    def _on_full_map_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Mapa generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el mapa STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D del mapa generado&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QPushButton, QFileDialog,&#10;                         QStackedWidget, QMessageBox, QLabel, QHBoxLayout, QDialog, &#10;                         QRadioButton, QGroupBox)&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtGui import QIcon, QPixmap&#10;from ui.map_selector_widget import MapSelectorWidget&#10;from ui.progress_dialog import ProgressDialog&#10;from ui.viewer_3d import Viewer3D&#10;from ui.workers import STLWorker&#10;from core.paths import Paths&#10;import os&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Mapa 3D Ecuador - Generador de STL&quot;)&#10;        self.resize(1200, 800)&#10;        Paths.ensure()&#10;&#10;        self.stack = QStackedWidget()&#10;        self.setCentralWidget(self.stack)&#10;&#10;        # Main menu&#10;        self.menu_page = QWidget()&#10;        self.create_main_menu()&#10;        self.stack.addWidget(self.menu_page)&#10;&#10;        # Map page&#10;        self.map_page = MapSelectorWidget(on_selected=self._on_tile_selected, on_back=self._go_menu)&#10;        self.stack.addWidget(self.map_page)&#10;&#10;        # Viewer page&#10;        self.viewer_page = Viewer3D(back_cb=self._go_menu)&#10;        self.stack.addWidget(self.viewer_page)&#10;&#10;        # Variables de estado&#10;        self.progress_dlg = None&#10;        self.worker = None&#10;&#10;        # Mostrar menú principal al inicio&#10;        self._go_menu()&#10;&#10;    def create_main_menu(self):&#10;        layout = QVBoxLayout(self.menu_page)&#10;&#10;        # Título&#10;        title_label = QLabel(&quot;Generador 3D de Terreno - Ecuador&quot;)&#10;        title_label.setStyleSheet(&quot;font-size: 24pt; font-weight: bold; color: #2c3e50; margin: 20px;&quot;)&#10;        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(title_label)&#10;&#10;        # Descripción&#10;        desc_label = QLabel(&quot;Seleccione una opción para comenzar:&quot;)&#10;        desc_label.setStyleSheet(&quot;font-size: 14pt; margin-bottom: 20px;&quot;)&#10;        desc_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        layout.addWidget(desc_label)&#10;&#10;        # Contenedor principal para los botones&#10;        btn_container = QWidget()&#10;        btn_layout = QVBoxLayout(btn_container)&#10;&#10;        # Estilo común para botones&#10;        button_style = &quot;&quot;&quot;&#10;        QPushButton {&#10;            font-size: 14pt;&#10;            padding: 12px;&#10;            margin: 10px 50px;&#10;            background-color: #3498db;&#10;            color: white;&#10;            border-radius: 8px;&#10;            min-width: 300px;&#10;        }&#10;        QPushButton:hover {&#10;            background-color: #2980b9;&#10;        }&#10;        &quot;&quot;&quot;&#10;&#10;        # Botones principales&#10;        self.btn_map = QPushButton(&quot;Seleccionar Zona en Mapa&quot;)&#10;        self.btn_map.setStyleSheet(button_style)&#10;&#10;        # Nuevo botón para generar todo el mapa&#10;        self.btn_full_map = QPushButton(&quot;Generar Todo el Mapa de Ecuador&quot;)&#10;        self.btn_full_map.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#27ae60&quot;).replace(&quot;#2980b9&quot;, &quot;#219955&quot;))&#10;&#10;        self.btn_open_stl = QPushButton(&quot;Abrir Modelo STL Existente&quot;)&#10;        self.btn_open_stl.setStyleSheet(button_style)&#10;        self.btn_settings = QPushButton(&quot;Configurar Carpetas de Datos&quot;)&#10;        self.btn_settings.setStyleSheet(button_style)&#10;        self.btn_exit = QPushButton(&quot;Salir&quot;)&#10;        self.btn_exit.setStyleSheet(button_style.replace(&quot;#3498db&quot;, &quot;#e74c3c&quot;).replace(&quot;#2980b9&quot;, &quot;#c0392b&quot;))&#10;&#10;        btn_layout.addWidget(self.btn_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_full_map, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_open_stl, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_settings, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        btn_layout.addWidget(self.btn_exit, alignment=Qt.AlignmentFlag.AlignCenter)&#10;&#10;        layout.addWidget(btn_container)&#10;        layout.addStretch()&#10;&#10;        # Conexiones de botones&#10;        self.btn_map.clicked.connect(self._go_map)&#10;        self.btn_full_map.clicked.connect(self._generate_full_map)&#10;        self.btn_open_stl.clicked.connect(self._open_stl)&#10;        self.btn_settings.clicked.connect(self._settings)&#10;        self.btn_exit.clicked.connect(self.close)&#10;&#10;    def _go_menu(self):&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;    def _go_map(self):&#10;        self.map_page.load()&#10;        self.stack.setCurrentWidget(self.map_page)&#10;&#10;    def _open_stl(self):&#10;        fn, _ = QFileDialog.getOpenFileName(self, &quot;Abrir STL&quot;, str(Paths.stl_dir), &quot;STL (*.stl)&quot;)&#10;        if fn:&#10;            # Mostrar diálogo de carga mientras se abre el modelo&#10;            loading_dialog = ProgressDialog(&quot;Cargando modelo STL...&quot;)&#10;            loading_dialog.show()&#10;&#10;            def open_model():&#10;                loading_dialog.update_progress(50, f&quot;Cargando {os.path.basename(fn)}...&quot;)&#10;                self.viewer_page.load_stl(fn)&#10;                self.stack.setCurrentWidget(self.viewer_page)&#10;                loading_dialog.close()&#10;&#10;            # Usar QTimer para permitir que se muestre el diálogo antes de cargar&#10;            QTimer.singleShot(300, open_model)&#10;&#10;    def _settings(self):&#10;        # Configuración de carpetas&#10;        settings_dialog = QDialog(self)&#10;        settings_dialog.setWindowTitle(&quot;Configuración&quot;)&#10;        settings_dialog.setMinimumWidth(500)&#10;&#10;        layout = QVBoxLayout(settings_dialog)&#10;&#10;        # HGT Directory&#10;        hgt_layout = QHBoxLayout()&#10;        hgt_label = QLabel(&quot;Carpeta de archivos HGT:&quot;)&#10;        hgt_path = QLabel(str(Paths.hgt_dir))&#10;        hgt_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        hgt_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        hgt_layout.addWidget(hgt_label)&#10;        hgt_layout.addWidget(hgt_path, 1)  # 1 = stretch factor&#10;        hgt_layout.addWidget(hgt_btn)&#10;&#10;        # STL Directory&#10;        stl_layout = QHBoxLayout()&#10;        stl_label = QLabel(&quot;Carpeta de modelos STL:&quot;)&#10;        stl_path = QLabel(str(Paths.stl_dir))&#10;        stl_path.setStyleSheet(&quot;font-weight: bold;&quot;)&#10;        stl_btn = QPushButton(&quot;Cambiar...&quot;)&#10;&#10;        stl_layout.addWidget(stl_label)&#10;        stl_layout.addWidget(stl_path, 1)  # 1 = stretch factor&#10;        stl_layout.addWidget(stl_btn)&#10;&#10;        # Close button&#10;        close_btn = QPushButton(&quot;Cerrar&quot;)&#10;        close_btn.clicked.connect(settings_dialog.accept)&#10;&#10;        layout.addLayout(hgt_layout)&#10;        layout.addLayout(stl_layout)&#10;        layout.addWidget(close_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;        # Connect buttons&#10;        def change_hgt():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de HGT&quot;, str(Paths.hgt_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_hgt_dir(new_dir)&#10;                self.map_page.hgt_root = str(Paths.hgt_dir)&#10;                hgt_path.setText(str(Paths.hgt_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta HGT configurada en:\n{Paths.hgt_dir}&quot;)&#10;&#10;        def change_stl():&#10;            new_dir = QFileDialog.getExistingDirectory(settings_dialog, &quot;Seleccionar carpeta de STL&quot;, str(Paths.stl_dir))&#10;            if new_dir:&#10;                # Actualizar la ruta utilizando el método de Paths&#10;                Paths.update_stl_dir(new_dir)&#10;                stl_path.setText(str(Paths.stl_dir))&#10;                QMessageBox.information(settings_dialog, &quot;Configuración actualizada&quot;,&#10;                                       f&quot;Carpeta STL configurada en:\n{Paths.stl_dir}&quot;)&#10;&#10;        hgt_btn.clicked.connect(change_hgt)&#10;        stl_btn.clicked.connect(change_stl)&#10;&#10;        settings_dialog.exec()&#10;&#10;    def _on_tile_selected(self, hgt_path: str):&#10;        # 1. Volver al menú principal y mostrar progreso&#10;        self.stack.setCurrentWidget(self.menu_page)&#10;&#10;        # 2. Mostrar diálogo de progreso con estilo mejorado&#10;        self.progress_dlg = ProgressDialog(&quot;Generando modelo 3D...&quot;)&#10;        self.progress_dlg.setWindowTitle(f&quot;Generando modelo de {os.path.basename(hgt_path)}&quot;)&#10;        self.progress_dlg.show()&#10;&#10;        # 3. Iniciar worker en segundo plano&#10;        self.worker = STLWorker(hgt_path)&#10;        self.worker.progress.connect(self.progress_dlg.update_progress)&#10;        self.worker.finished.connect(self._on_generation_finished)&#10;        self.worker.start()&#10;&#10;    def _on_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Modelo generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)&#10;&#10;    def _generate_full_map(self):&#10;        # Crear un diálogo para seleccionar opciones&#10;        options_dialog = QDialog(self)&#10;        options_dialog.setWindowTitle(&quot;Opciones de Generación de Mapa&quot;)&#10;        options_dialog.setMinimumWidth(400)&#10;&#10;        layout = QVBoxLayout(options_dialog)&#10;&#10;        # Título&#10;        title = QLabel(&quot;Selecciona las opciones para generar el mapa:&quot;)&#10;        title.setStyleSheet(&quot;font-size: 14pt; font-weight: bold; margin-bottom: 15px;&quot;)&#10;        layout.addWidget(title)&#10;&#10;        # Opciones de área&#10;        area_group = QGroupBox(&quot;Área a generar:&quot;)&#10;        area_layout = QVBoxLayout()&#10;&#10;        ecuador_radio = QRadioButton(&quot;Solo Ecuador (más rápido)&quot;)&#10;        ecuador_radio.setChecked(True)&#10;        all_radio = QRadioButton(&quot;Todos los archivos HGT disponibles&quot;)&#10;&#10;        area_layout.addWidget(ecuador_radio)&#10;        area_layout.addWidget(all_radio)&#10;        area_group.setLayout(area_layout)&#10;&#10;        # Opciones de resolución&#10;        resolution_group = QGroupBox(&quot;Resolución:&quot;)&#10;        resolution_layout = QVBoxLayout()&#10;&#10;        low_radio = QRadioButton(&quot;Baja (más rápido, archivo pequeño)&quot;)&#10;        medium_radio = QRadioButton(&quot;Media (equilibrado)&quot;)&#10;        high_radio = QRadioButton(&quot;Alta (más detalle, archivo grande)&quot;)&#10;&#10;        medium_radio.setChecked(True)&#10;&#10;        resolution_layout.addWidget(low_radio)&#10;        resolution_layout.addWidget(medium_radio)&#10;        resolution_layout.addWidget(high_radio)&#10;        resolution_group.setLayout(resolution_layout)&#10;&#10;        # Botones&#10;        buttons = QHBoxLayout()&#10;        cancel_btn = QPushButton(&quot;Cancelar&quot;)&#10;        generate_btn = QPushButton(&quot;Generar&quot;)&#10;        generate_btn.setStyleSheet(&quot;background-color: #27ae60; color: white; font-weight: bold;&quot;)&#10;&#10;        buttons.addWidget(cancel_btn)&#10;        buttons.addWidget(generate_btn)&#10;&#10;        # Añadir todo al layout principal&#10;        layout.addWidget(area_group)&#10;        layout.addWidget(resolution_group)&#10;        layout.addLayout(buttons)&#10;&#10;        # Conexiones&#10;        cancel_btn.clicked.connect(options_dialog.reject)&#10;        generate_btn.clicked.connect(options_dialog.accept)&#10;&#10;        # Mostrar diálogo&#10;        if options_dialog.exec() == QDialog.DialogCode.Accepted:&#10;            # Obtener opciones seleccionadas&#10;            only_ecuador = ecuador_radio.isChecked()&#10;&#10;            if low_radio.isChecked():&#10;                resolution = &quot;low&quot;&#10;            elif high_radio.isChecked():&#10;                resolution = &quot;high&quot;&#10;            else:&#10;                resolution = &quot;medium&quot;&#10;&#10;            # 1. Volver al menú principal y mostrar progreso&#10;            self.stack.setCurrentWidget(self.menu_page)&#10;&#10;            # 2. Mostrar diálogo de progreso para la generación del mapa&#10;            area_text = &quot;Ecuador&quot; if only_ecuador else &quot;todos los archivos HGT&quot;&#10;            title_text = f&quot;Generando mapa 3D de {area_text}&quot;&#10;&#10;            self.progress_dlg = ProgressDialog(title_text)&#10;            self.progress_dlg.setWindowTitle(title_text)&#10;            self.progress_dlg.show()&#10;&#10;            # 3. Iniciar worker en segundo plano para la generación del mapa&#10;            self.worker = STLWorker(generate_full_map=True, only_ecuador=only_ecuador, resolution=resolution)&#10;            self.worker.progress.connect(self.progress_dlg.update_progress)&#10;            self.worker.finished.connect(self._on_full_map_generation_finished)&#10;            self.worker.start()&#10;        else:&#10;            # Cancelado&#10;            return&#10;&#10;    def _on_full_map_generation_finished(self, success: bool, stl_path: str, err: str):&#10;        if self.progress_dlg:&#10;            # Mostrar finalización en la barra de progreso&#10;            if success:&#10;                self.progress_dlg.update_progress(100, &quot;¡Mapa generado correctamente!&quot;)&#10;                # Breve pausa para mostrar el 100% antes de cerrar&#10;                QTimer.singleShot(800, self.progress_dlg.close)&#10;            else:&#10;                self.progress_dlg.close()&#10;                self.progress_dlg = None&#10;&#10;        if not success:&#10;            QMessageBox.critical(self, &quot;Error&quot;, f&quot;Ocurrió un error generando el mapa STL:\n{err}&quot;)&#10;            self._go_menu()&#10;            return&#10;&#10;        # 4. Mostrar modelo 3D del mapa generado&#10;        self.viewer_page.load_stl(stl_path)&#10;        self.stack.setCurrentWidget(self.viewer_page)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/map_selector_widget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/map_selector_widget.py" />
              <option name="originalContent" value="from typing import Callable, List, Tuple&#10;from PyQt6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QLabel&#10;from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas&#10;from matplotlib.figure import Figure&#10;from matplotlib.patches import Rectangle&#10;import geopandas as gpd&#10;from core.hgt_utils import find_hgt_files&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;&#10;class MapSelectorWidget(QWidget):&#10;    def __init__(self, on_selected: Callable[[str], None], on_back: Callable[[], None], hgt_root=None):&#10;        super().__init__()&#10;        self.on_selected = on_selected&#10;        self.hgt_root = hgt_root&#10;        top = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver&quot;)&#10;        top.addWidget(self.back_btn)&#10;        self.title = QLabel(&quot;Selecciona una zona HGT (clic)&quot;)&#10;        top.addWidget(self.title)&#10;        top.addStretch()&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(top)&#10;&#10;        self.fig = Figure(figsize=(10, 6), tight_layout=True)&#10;        self.canvas = FigureCanvas(self.fig)&#10;        layout.addWidget(self.canvas)&#10;        self.ax = self.fig.add_subplot(111)&#10;        self.ax.set_title(&quot;Ecuador y tiles HGT&quot;)&#10;        self.ax.set_xlabel(&quot;Longitud&quot;)&#10;        self.ax.set_ylabel(&quot;Latitud&quot;)&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;&#10;        self.rectangles: List[Tuple[Rectangle, dict]] = []&#10;        self.canvas.mpl_connect(&quot;pick_event&quot;, self._on_pick)&#10;        self.back_btn.clicked.connect(on_back)&#10;&#10;    def load(self):&#10;        self.ax.clear()&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;        # Ecuador boundary&#10;        gp = get_ecuador_geojson()&#10;        if gp:&#10;            gdf = gpd.read_file(gp)&#10;            gdf.boundary.plot(ax=self.ax, color=&quot;green&quot;, linewidth=2)&#10;&#10;        # HGT tiles&#10;        files = find_hgt_files(self.hgt_root, only_ecuador=True)&#10;        if not files:&#10;            self.ax.set_title(&quot;No se encontraron HGT en Ecuador&quot;)&#10;            self.canvas.draw()&#10;            return&#10;&#10;        lats = [f[&quot;lat&quot;] for f in files]&#10;        lons = [f[&quot;lon&quot;] for f in files]&#10;        self.ax.set_xlim(min(lons)-1, max(lons)+1)&#10;        self.ax.set_ylim(min(lats)-1, max(lats)+1)&#10;&#10;        self.rectangles.clear()&#10;        for f in files:&#10;            rect = Rectangle((f['lon'], f['lat']), 1, 1, edgecolor='black',&#10;                             facecolor='lightgray', alpha=0.7, picker=True)&#10;            self.ax.add_patch(rect)&#10;            self.ax.text(f['lon']+0.5, f['lat']+0.5, f['name'], ha='center', va='center', fontsize=7)&#10;            self.rectangles.append((rect, f))&#10;&#10;        self.canvas.draw()&#10;&#10;    def _on_pick(self, event):&#10;        artist = event.artist&#10;        for rect, info in self.rectangles:&#10;            if artist == rect:&#10;                self.on_selected(info[&quot;path&quot;])&#10;                break" />
              <option name="updatedContent" value="from typing import Callable, List, Tuple&#10;from PyQt6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QLabel&#10;from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas&#10;from matplotlib.figure import Figure&#10;from matplotlib.patches import Rectangle&#10;import geopandas as gpd&#10;from core.hgt_utils import find_hgt_files&#10;from core.ecuador_boundary import get_ecuador_geojson&#10;from core.paths import Paths&#10;&#10;class MapSelectorWidget(QWidget):&#10;    def __init__(self, on_selected: Callable[[str], None], on_back: Callable[[], None], hgt_root=None):&#10;        super().__init__()&#10;        self.on_selected = on_selected&#10;        self.hgt_root = hgt_root&#10;        top = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver&quot;)&#10;        top.addWidget(self.back_btn)&#10;        self.title = QLabel(&quot;Selecciona una zona HGT (clic)&quot;)&#10;        top.addWidget(self.title)&#10;        top.addStretch()&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(top)&#10;&#10;        self.fig = Figure(figsize=(10, 6), tight_layout=True)&#10;        self.canvas = FigureCanvas(self.fig)&#10;        layout.addWidget(self.canvas)&#10;        self.ax = self.fig.add_subplot(111)&#10;        self.ax.set_title(&quot;Ecuador y tiles HGT&quot;)&#10;        self.ax.set_xlabel(&quot;Longitud&quot;)&#10;        self.ax.set_ylabel(&quot;Latitud&quot;)&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;&#10;        self.rectangles: List[Tuple[Rectangle, dict]] = []&#10;        self.canvas.mpl_connect(&quot;pick_event&quot;, self._on_pick)&#10;        self.back_btn.clicked.connect(on_back)&#10;&#10;    def load(self):&#10;        self.ax.clear()&#10;        self.ax.set_aspect(&quot;equal&quot;)&#10;        &#10;        # Mostrar ruta actual de búsqueda HGT&#10;        print(f&quot;Buscando archivos HGT en: {self.hgt_root or Paths.hgt_dir}&quot;)&#10;        &#10;        # Ecuador boundary&#10;        gp = get_ecuador_geojson()&#10;        if gp:&#10;            print(f&quot;Archivo GeoJSON cargado: {gp}&quot;)&#10;            try:&#10;                gdf = gpd.read_file(gp)&#10;                gdf.boundary.plot(ax=self.ax, color=&quot;green&quot;, linewidth=2)&#10;            except Exception as e:&#10;                print(f&quot;Error al cargar GeoJSON: {e}&quot;)&#10;                self.ax.set_title(&quot;Error al cargar límites de Ecuador&quot;)&#10;                self.canvas.draw()&#10;                return&#10;&#10;        # HGT tiles&#10;        try:&#10;            files = find_hgt_files(self.hgt_root, only_ecuador=True)&#10;            print(f&quot;Archivos HGT encontrados: {len(files)}&quot;)&#10;            &#10;            if not files:&#10;                print(&quot;No se encontraron archivos HGT en Ecuador&quot;)&#10;                self.ax.set_title(&quot;No se encontraron HGT en Ecuador&quot;)&#10;                self.canvas.draw()&#10;                return&#10;                &#10;        except Exception as e:&#10;            print(f&quot;Error al buscar archivos HGT: {e}&quot;)&#10;            self.ax.set_title(f&quot;Error al buscar archivos HGT: {str(e)}&quot;)&#10;            self.canvas.draw()&#10;            return&#10;&#10;        lats = [f[&quot;lat&quot;] for f in files]&#10;        lons = [f[&quot;lon&quot;] for f in files]&#10;        self.ax.set_xlim(min(lons)-1, max(lons)+1)&#10;        self.ax.set_ylim(min(lats)-1, max(lats)+1)&#10;&#10;        self.rectangles.clear()&#10;        for f in files:&#10;            rect = Rectangle((f['lon'], f['lat']), 1, 1, edgecolor='black',&#10;                             facecolor='lightgray', alpha=0.7, picker=True)&#10;            self.ax.add_patch(rect)&#10;            self.ax.text(f['lon']+0.5, f['lat']+0.5, f['name'], ha='center', va='center', fontsize=7)&#10;            self.rectangles.append((rect, f))&#10;&#10;        self.canvas.draw()&#10;&#10;    def _on_pick(self, event):&#10;        artist = event.artist&#10;        for rect, info in self.rectangles:&#10;            if artist == rect:&#10;                self.on_selected(info[&quot;path&quot;])&#10;                break" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/progress_dialog.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/progress_dialog.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QPushButton&#10;from PyQt6.QtCore import Qt&#10;&#10;class ProgressDialog(QDialog):&#10;    def __init__(self, title=&quot;Procesando...&quot;):&#10;        super().__init__()&#10;        self.setWindowTitle(title)&#10;        self.setModal(True)&#10;        self.setFixedSize(420, 140)&#10;        layout = QVBoxLayout(self)&#10;        self.label = QLabel(&quot;Iniciando...&quot;)&#10;        self.bar = QProgressBar()&#10;        self.bar.setRange(0, 100)&#10;        self.cancel_btn = QPushButton(&quot;Cancelar&quot;)&#10;        layout.addWidget(self.label)&#10;        layout.addWidget(self.bar)&#10;        layout.addWidget(self.cancel_btn, alignment=Qt.AlignmentFlag.AlignRight)&#10;&#10;    def update_progress(self, val: int, text: str = &quot;&quot;):&#10;        self.bar.setValue(val)&#10;        if text:&#10;            self.label.setText(text)" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QPushButton&#13;&#10;from PyQt6.QtCore import Qt, QTimer&#13;&#10;&#13;&#10;class ProgressDialog(QDialog):&#13;&#10;    def __init__(self, title=&quot;Procesando...&quot;):&#13;&#10;        super().__init__()&#13;&#10;        self.setWindowTitle(title)&#13;&#10;        self.setModal(True)&#13;&#10;        self.setFixedSize(480, 180)&#13;&#10;        &#13;&#10;        layout = QVBoxLayout(self)&#13;&#10;        &#13;&#10;        # Título más grande y visible&#13;&#10;        self.title_label = QLabel(title)&#13;&#10;        self.title_label.setStyleSheet(&quot;font-size: 14pt; font-weight: bold;&quot;)&#13;&#10;        layout.addWidget(self.title_label)&#13;&#10;        &#13;&#10;        # Etiqueta de estado&#13;&#10;        self.label = QLabel(&quot;Iniciando proceso...&quot;)&#13;&#10;        self.label.setStyleSheet(&quot;font-size: 11pt;&quot;)&#13;&#10;        layout.addWidget(self.label)&#13;&#10;        &#13;&#10;        # Barra de progreso más grande&#13;&#10;        self.bar = QProgressBar()&#13;&#10;        self.bar.setRange(0, 100)&#13;&#10;        self.bar.setTextVisible(True)&#13;&#10;        self.bar.setMinimumHeight(25)&#13;&#10;        layout.addWidget(self.bar)&#13;&#10;        &#13;&#10;        # Botón de cancelar&#13;&#10;        self.cancel_btn = QPushButton(&quot;Cancelar&quot;)&#13;&#10;        self.cancel_btn.setFixedWidth(100)&#13;&#10;        layout.addWidget(self.cancel_btn, alignment=Qt.AlignmentFlag.AlignRight)&#13;&#10;        &#13;&#10;        # Para animación en caso de que no haya actualizaciones&#13;&#10;        self.timer = QTimer()&#13;&#10;        self.timer.timeout.connect(self._pulse)&#13;&#10;        self.timer.start(150)&#13;&#10;        &#13;&#10;    def _pulse(self):&#13;&#10;        # Solo anima si no hay progreso definido (valor = 0)&#13;&#10;        if self.bar.value() == 0:&#13;&#10;            v = (self.bar.value() + 1) % 100&#13;&#10;            self.bar.setValue(v)&#13;&#10;    &#13;&#10;    def update_progress(self, val: int, text: str = &quot;&quot;):&#13;&#10;        # Detener animación si recibimos valor real&#13;&#10;        if val &gt; 0:&#13;&#10;            self.timer.stop()&#13;&#10;            &#13;&#10;        self.bar.setValue(val)&#13;&#10;        if text:&#13;&#10;            self.label.setText(text)&#13;&#10;            &#13;&#10;    def closeEvent(self, event):&#13;&#10;        self.timer.stop()&#13;&#10;        super().closeEvent(event)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/viewer_3d.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/viewer_3d.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel&#10;from pyvistaqt import QtInteractor&#10;import pyvista as pv&#10;from pathlib import Path&#10;&#10;class Viewer3D(QWidget):&#10;    def __init__(self, back_cb):&#10;        super().__init__()&#10;        self.back_cb = back_cb&#10;        self.plotter = QtInteractor(self)&#10;        self.info = QLabel(&quot;&quot;)&#10;        btns = QHBoxLayout()&#10;        self.back_btn = QPushButton(&quot;Volver al menú&quot;)&#10;        btns.addWidget(self.back_btn)&#10;        layout = QVBoxLayout(self)&#10;        layout.addLayout(btns)&#10;        layout.addWidget(self.plotter.interactor)&#10;        layout.addWidget(self.info)&#10;        self.back_btn.clicked.connect(self.back_cb)&#10;&#10;    def load_stl(self, stl_path: str):&#10;        self.plotter.clear()&#10;        mesh = pv.read(stl_path)&#10;        self.plotter.add_mesh(mesh, cmap=&quot;terrain&quot;, show_edges=False, lighting=True)&#10;        self.plotter.enable_eye_dome_lighting()&#10;        self.plotter.show_grid()&#10;        self.plotter.reset_camera()&#10;        self.info.setText(f&quot;Archivo: {Path(stl_path).name}&quot;)" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, &#13;&#10;                         QLabel, QFileDialog, QSizePolicy, QFrame, QComboBox)&#13;&#10;from PyQt6.QtCore import Qt&#13;&#10;from pyvistaqt import QtInteractor&#13;&#10;import pyvista as pv&#13;&#10;from pathlib import Path&#13;&#10;import os&#13;&#10;from core.paths import Paths&#13;&#10;&#13;&#10;class Viewer3D(QWidget):&#13;&#10;    def __init__(self, back_cb):&#13;&#10;        super().__init__()&#13;&#10;        self.back_cb = back_cb&#13;&#10;        self.current_file = None&#13;&#10;        &#13;&#10;        # Crear layout principal&#13;&#10;        main_layout = QVBoxLayout(self)&#13;&#10;        main_layout.setContentsMargins(10, 10, 10, 10)&#13;&#10;        main_layout.setSpacing(10)&#13;&#10;        &#13;&#10;        # Panel superior con controles&#13;&#10;        top_panel = QFrame()&#13;&#10;        top_panel.setFrameShape(QFrame.Shape.StyledPanel)&#13;&#10;        top_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)&#13;&#10;        &#13;&#10;        top_layout = QHBoxLayout(top_panel)&#13;&#10;        &#13;&#10;        # Botón de volver al menú&#13;&#10;        self.back_btn = QPushButton(&quot;← Volver al Menú&quot;)&#13;&#10;        self.back_btn.setMinimumWidth(150)&#13;&#10;        self.back_btn.clicked.connect(self.back_cb)&#13;&#10;        &#13;&#10;        # Información del archivo&#13;&#10;        self.info = QLabel(&quot;&quot;)&#13;&#10;        self.info.setStyleSheet(&quot;font-size: 12pt; font-weight: bold;&quot;)&#13;&#10;        self.info.setAlignment(Qt.AlignmentFlag.AlignCenter)&#13;&#10;        &#13;&#10;        # Controles adicionales&#13;&#10;        self.save_btn = QPushButton(&quot;Guardar STL como...&quot;)&#13;&#10;        self.save_btn.setMinimumWidth(150)&#13;&#10;        self.save_btn.clicked.connect(self._save_stl)&#13;&#10;        &#13;&#10;        # Selector de estilo de visualización&#13;&#10;        self.view_style = QComboBox()&#13;&#10;        self.view_style.addItems([&quot;Terreno&quot;, &quot;Sólido&quot;, &quot;Wireframe&quot;, &quot;Puntos&quot;])&#13;&#10;        self.view_style.currentIndexChanged.connect(self._change_view_style)&#13;&#10;        &#13;&#10;        # Agregar widgets al panel superior&#13;&#10;        top_layout.addWidget(self.back_btn)&#13;&#10;        top_layout.addWidget(self.info, 1)  # 1 = stretch factor&#13;&#10;        top_layout.addWidget(self.view_style)&#13;&#10;        top_layout.addWidget(self.save_btn)&#13;&#10;        &#13;&#10;        # Panel de visualización 3D&#13;&#10;        viewer_panel = QFrame()&#13;&#10;        viewer_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#13;&#10;        viewer_layout = QVBoxLayout(viewer_panel)&#13;&#10;        viewer_layout.setContentsMargins(0, 0, 0, 0)&#13;&#10;        &#13;&#10;        # Inicializar plotter de PyVista&#13;&#10;        self.plotter = QtInteractor(self)&#13;&#10;        viewer_layout.addWidget(self.plotter.interactor)&#13;&#10;        &#13;&#10;        # Panel inferior con información adicional&#13;&#10;        bottom_panel = QFrame()&#13;&#10;        bottom_panel.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)&#13;&#10;        bottom_layout = QHBoxLayout(bottom_panel)&#13;&#10;        &#13;&#10;        self.model_info = QLabel(&quot;&quot;)&#13;&#10;        self.model_info.setStyleSheet(&quot;font-style: italic;&quot;)&#13;&#10;        bottom_layout.addWidget(self.model_info)&#13;&#10;        &#13;&#10;        # Agregar paneles al layout principal&#13;&#10;        main_layout.addWidget(top_panel)&#13;&#10;        main_layout.addWidget(viewer_panel, 1)  # 1 = stretch factor&#13;&#10;        main_layout.addWidget(bottom_panel)&#13;&#10;        &#13;&#10;    def load_stl(self, stl_path: str):&#13;&#10;        &quot;&quot;&quot;Carga un archivo STL y lo muestra en el visualizador 3D&quot;&quot;&quot;&#13;&#10;        self.current_file = stl_path&#13;&#10;        self.plotter.clear()&#13;&#10;        &#13;&#10;        try:&#13;&#10;            # Cargar mesh&#13;&#10;            mesh = pv.read(stl_path)&#13;&#10;            &#13;&#10;            # Mostrar el modelo con el estilo por defecto (Terreno)&#13;&#10;            self._display_mesh(mesh, style=&quot;terrain&quot;)&#13;&#10;            &#13;&#10;            # Actualizar información&#13;&#10;            file_name = Path(stl_path).name&#13;&#10;            self.info.setText(f&quot;Modelo: {file_name}&quot;)&#13;&#10;            &#13;&#10;            # Mostrar estadísticas del modelo&#13;&#10;            n_points = mesh.n_points&#13;&#10;            n_cells = mesh.n_cells&#13;&#10;            self.model_info.setText(f&quot;Puntos: {n_points:,} | Caras: {n_cells:,} | Archivo: {os.path.abspath(stl_path)}&quot;)&#13;&#10;            &#13;&#10;        except Exception as e:&#13;&#10;            self.info.setText(f&quot;Error al cargar el modelo: {str(e)}&quot;)&#13;&#10;            self.model_info.setText(&quot;&quot;)&#13;&#10;    &#13;&#10;    def _change_view_style(self, index):&#13;&#10;        &quot;&quot;&quot;Cambia el estilo de visualización del modelo&quot;&quot;&quot;&#13;&#10;        if self.current_file is None:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # Volver a cargar el mesh&#13;&#10;        mesh = pv.read(self.current_file)&#13;&#10;        &#13;&#10;        # Aplicar el estilo seleccionado&#13;&#10;        styles = [&quot;terrain&quot;, &quot;default&quot;, &quot;wireframe&quot;, &quot;points&quot;]&#13;&#10;        selected_style = styles[index] if index &lt; len(styles) else &quot;terrain&quot;&#13;&#10;        &#13;&#10;        self._display_mesh(mesh, style=selected_style)&#13;&#10;    &#13;&#10;    def _display_mesh(self, mesh, style=&quot;terrain&quot;):&#13;&#10;        &quot;&quot;&quot;Muestra un mesh con el estilo especificado&quot;&quot;&quot;&#13;&#10;        self.plotter.clear()&#13;&#10;        &#13;&#10;        if style == &quot;terrain&quot;:&#13;&#10;            # Estilo de terreno con colores según elevación&#13;&#10;            self.plotter.add_mesh(mesh, cmap=&quot;terrain&quot;, show_edges=False, lighting=True)&#13;&#10;            self.plotter.enable_eye_dome_lighting()&#13;&#10;        elif style == &quot;wireframe&quot;:&#13;&#10;            # Estilo de wireframe&#13;&#10;            self.plotter.add_mesh(mesh, style=&quot;wireframe&quot;, color=&quot;black&quot;, line_width=1)&#13;&#10;        elif style == &quot;points&quot;:&#13;&#10;            # Estilo de puntos&#13;&#10;            self.plotter.add_mesh(mesh, style=&quot;points&quot;, color=&quot;blue&quot;, point_size=5)&#13;&#10;        else:&#13;&#10;            # Estilo por defecto (sólido)&#13;&#10;            self.plotter.add_mesh(mesh, color=&quot;lightgray&quot;, show_edges=True)&#13;&#10;        &#13;&#10;        self.plotter.show_grid()&#13;&#10;        self.plotter.reset_camera()&#13;&#10;        &#13;&#10;    def _save_stl(self):&#13;&#10;        &quot;&quot;&quot;Guarda el modelo STL actual en una nueva ubicación&quot;&quot;&quot;&#13;&#10;        if self.current_file is None:&#13;&#10;            return&#13;&#10;            &#13;&#10;        original_filename = Path(self.current_file).stem&#13;&#10;        &#13;&#10;        # Mostrar diálogo para guardar archivo&#13;&#10;        file_path, _ = QFileDialog.getSaveFileName(&#13;&#10;            self,&#13;&#10;            &quot;Guardar STL como&quot;,&#13;&#10;            str(Paths.stl_dir / f&quot;{original_filename}_copy.stl&quot;),&#13;&#10;            &quot;STL Files (*.stl)&quot;&#13;&#10;        )&#13;&#10;        &#13;&#10;        if file_path:&#13;&#10;            try:&#13;&#10;                # Leer el mesh original y guardarlo en la nueva ubicación&#13;&#10;                mesh = pv.read(self.current_file)&#13;&#10;                mesh.save(file_path)&#13;&#10;                &#13;&#10;                # Actualizar información&#13;&#10;                self.model_info.setText(f&quot;Guardado como: {file_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                self.model_info.setText(f&quot;Error al guardar: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/workers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/workers.py" />
              <option name="originalContent" value="from PyQt6.QtCore import QThread, pyqtSignal&#10;from core.stl_generator import generate_stl_from_hgt, generate_full_ecuador_map&#10;from core.hgt_utils import find_hgt_files&#10;&#10;class STLWorker(QThread):&#10;    progress = pyqtSignal(int, str)&#10;    finished = pyqtSignal(bool, str, str)  # success, stl_path, error_msg&#10;&#10;    def __init__(self, hgt_path: str = None, out_dir: str = None, generate_full_map: bool = False,&#10;                 only_ecuador: bool = True, resolution: str = &quot;medium&quot;):&#10;        super().__init__()&#10;        self.hgt_path = hgt_path&#10;        self.out_dir = out_dir&#10;        self.generate_full_map = generate_full_map&#10;        self.only_ecuador = only_ecuador&#10;        self.resolution = resolution&#10;&#10;    def run(self):&#10;        try:&#10;            def cb(val, msg):&#10;                self.progress.emit(val, msg)&#10;&#10;            if self.generate_full_map:&#10;                # Generar el mapa completo con las opciones seleccionadas&#10;                stl_path = generate_full_ecuador_map(&#10;                    progress_callback=cb,&#10;                    only_ecuador=self.only_ecuador,&#10;                    resolution=self.resolution&#10;                )&#10;            else:&#10;                # Generar un solo tile HGT&#10;                stl_path = generate_stl_from_hgt(self.hgt_path, self.out_dir, cb)&#10;&#10;            self.finished.emit(True, stl_path, &quot;&quot;)&#10;        except Exception as e:&#10;            self.finished.emit(False, &quot;&quot;, str(e))" />
              <option name="updatedContent" value="from PyQt6.QtCore import QThread, pyqtSignal&#10;from core.stl_generator import generate_stl_from_hgt, generate_full_ecuador_map&#10;from core.hgt_utils import find_hgt_files&#10;&#10;class STLWorker(QThread):&#10;    progress = pyqtSignal(int, str)&#10;    finished = pyqtSignal(bool, str, str)  # success, stl_path, error_msg&#10;&#10;    def __init__(self, hgt_path: str = None, out_dir: str = None, generate_full_map: bool = False,&#10;                 only_ecuador: bool = True, resolution: str = &quot;medium&quot;):&#10;        super().__init__()&#10;        self.hgt_path = hgt_path&#10;        self.out_dir = out_dir&#10;        self.generate_full_map = generate_full_map&#10;        self.only_ecuador = only_ecuador&#10;        self.resolution = resolution&#10;&#10;    def run(self):&#10;        try:&#10;            def cb(val, msg):&#10;                self.progress.emit(val, msg)&#10;            &#10;            if self.generate_full_map:&#10;                # Generar el mapa completo con las opciones seleccionadas&#10;                stl_path = generate_full_ecuador_map(&#10;                    progress_callback=cb,&#10;                    resolution=self.resolution,&#10;                    only_ecuador=self.only_ecuador&#10;                )&#10;            else:&#10;                # Generar un solo tile HGT&#10;                stl_path = generate_stl_from_hgt(self.hgt_path, self.out_dir, cb)&#10;                &#10;            self.finished.emit(True, stl_path, &quot;&quot;)&#10;        except Exception as e:&#10;            self.finished.emit(False, &quot;&quot;, str(e))" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>